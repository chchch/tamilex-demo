'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');
var ReactPaperJS = require('@psychobolt/react-paperjs');

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function () {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

var PathTool = /*#__PURE__*/function (_React$Component) {
  _inherits(PathTool, _React$Component);

  var _super = _createSuper(PathTool);

  function PathTool() {
    var _this;

    _classCallCheck(this, PathTool);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));
    _this.path = void 0;
    return _this;
  }

  return PathTool;
}(React.Component);

PathTool.defaultProps = {
  onKeyDown: function onKeyDown() {},
  onKeyUp: function onKeyUp() {},
  onMouseDown: function onMouseDown() {},
  onMouseDrag: function onMouseDrag() {},
  onMouseUp: function onMouseUp() {},
  onPathInit: function onPathInit() {},
  onPathAdd: function onPathAdd() {},
  onSegmentAdd: function onSegmentAdd() {},
  onSegmentRemove: function onSegmentRemove() {}
};

var _class, _class2, _temp;
var Tool = ReactPaperJS.Tool,
    PaperScope = ReactPaperJS.PaperScope;
var MOUSE_LEFT_CODE = 0; // $FlowFixMe

var FreeformPathTool = PaperScope(_class = (_temp = _class2 = /*#__PURE__*/function (_PathTool) {
  _inherits(FreeformPathTool, _PathTool);

  var _super = _createSuper(FreeformPathTool);

  function FreeformPathTool() {
    var _this;

    _classCallCheck(this, FreeformPathTool);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _this.onMouseDown = function (toolEvent) {
      var _this$props = _this.props,
          pathProps = _this$props.pathProps,
          onMouseDown = _this$props.onMouseDown,
          onPathInit = _this$props.onPathInit,
          paper = _this$props.paper;

      if (toolEvent.event.button === MOUSE_LEFT_CODE) {
        var path = new paper.Path(pathProps);
        _this.path = path;
        onPathInit(path);
      }

      onMouseDown(toolEvent);
    };

    _this.onMouseDrag = function (toolEvent) {
      var onMouseDrag = _this.props.onMouseDrag;

      if (toolEvent.event.buttons === 1) {
        _this.path.add(toolEvent.point);
      }

      onMouseDrag(toolEvent);
    };

    _this.onMouseUp = function (toolEvent) {
      var _assertThisInitialize = _assertThisInitialized(_this),
          path = _assertThisInitialize.path;

      var _this$props2 = _this.props,
          onMouseUp = _this$props2.onMouseUp,
          onPathAdd = _this$props2.onPathAdd;

      if (path) {
        onPathAdd(path);
        _this.path = null;
      }

      onMouseUp(toolEvent);
    };

    return _this;
  }

  _createClass(FreeformPathTool, [{
    key: "render",
    value: function render() {
      var _this$props3 = this.props,
          pathProps = _this$props3.pathProps,
          onMouseDown = _this$props3.onMouseDown,
          onMouseDrag = _this$props3.onMouseDrag,
          onMouseUp = _this$props3.onMouseUp,
          onPathAdd = _this$props3.onPathAdd,
          paper = _this$props3.paper,
          innerRef = _this$props3.innerRef,
          rest = _objectWithoutProperties(_this$props3, ["pathProps", "onMouseDown", "onMouseDrag", "onMouseUp", "onPathAdd", "paper", "innerRef"]);

      return /*#__PURE__*/React.createElement(Tool, _extends({
        ref: innerRef,
        minDistance: 10,
        onMouseDown: this.onMouseDown,
        onMouseDrag: this.onMouseDrag,
        onMouseUp: this.onMouseUp
      }, rest));
    }
  }]);

  return FreeformPathTool;
}(PathTool), _class2.defaultProps = _objectSpread2(_objectSpread2({}, PathTool.defaultProps), {}, {
  pathProps: {
    strokeColor: 'black'
  }
}), _temp)) || _class;

var FreeformPathTool_component = React.forwardRef(function (props, ref) {
  return /*#__PURE__*/React.createElement(FreeformPathTool, _extends({
    innerRef: ref
  }, props));
});

var Layer = ReactPaperJS.Layer,
    Group = ReactPaperJS.Group,
    Line = ReactPaperJS.Line;

var Grid = function Grid(_ref) {
  var width = _ref.width,
      height = _ref.height,
      _ref$top = _ref.top,
      top = _ref$top === void 0 ? 0 : _ref$top,
      _ref$left = _ref.left,
      left = _ref$left === void 0 ? 0 : _ref$left,
      _ref$right = _ref.right,
      right = _ref$right === void 0 ? left + width : _ref$right,
      _ref$bottom = _ref.bottom,
      bottom = _ref$bottom === void 0 ? top + height : _ref$bottom,
      _ref$cellSize = _ref.cellSize,
      cellSize = _ref$cellSize === void 0 ? 50 : _ref$cellSize,
      _ref$strokeColor = _ref.strokeColor,
      strokeColor = _ref$strokeColor === void 0 ? '#D0D0D0' : _ref$strokeColor,
      _ref$strokeWidth = _ref.strokeWidth,
      strokeWidth = _ref$strokeWidth === void 0 ? 1 : _ref$strokeWidth,
      innerRef = _ref.innerRef;
  var x = Math.ceil(left / cellSize) * cellSize;
  var y = Math.ceil(top / cellSize) * cellSize;
  var cols = Math.ceil((right - left) / cellSize);
  var rows = Math.ceil((bottom - top) / cellSize);
  var verticalLines = [];
  var horizontalLines = [];

  for (var i = 0; i <= cols; i += 1) {
    var position = x + i * cellSize;
    verticalLines.push( /*#__PURE__*/React.createElement(Line, {
      key: i,
      from: [position, top],
      to: [position, bottom],
      strokeColor: strokeColor,
      strokeWidth: strokeWidth
    }));
  }

  for (var _i = 0; _i <= rows; _i += 1) {
    var _position = y + _i * cellSize;

    horizontalLines.push( /*#__PURE__*/React.createElement(Line, {
      key: _i,
      from: [left, _position],
      to: [right, _position],
      strokeColor: strokeColor,
      strokeWidth: strokeWidth
    }));
  }

  return /*#__PURE__*/React.createElement(Layer, {
    ref: innerRef
  }, /*#__PURE__*/React.createElement(Group, null, verticalLines), /*#__PURE__*/React.createElement(Group, null, horizontalLines));
};

var Grid_component = React.forwardRef(function (props, ref) {
  return /*#__PURE__*/React.createElement(Grid, _extends({
    innerRef: ref
  }, props));
});

var _class$1, _class2$1, _temp$1;
var Tool$1 = ReactPaperJS.Tool,
    PaperScope$1 = ReactPaperJS.PaperScope;
var MOUSE_LEFT_CODE$1 = 0; // $FlowFixMe

var LineTool = PaperScope$1(_class$1 = (_temp$1 = _class2$1 = /*#__PURE__*/function (_PathTool) {
  _inherits(LineTool, _PathTool);

  var _super = _createSuper(LineTool);

  function LineTool() {
    var _this;

    _classCallCheck(this, LineTool);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _this.onMouseDown = function (toolEvent) {
      var _this$props = _this.props,
          pathProps = _this$props.pathProps,
          onMouseDown = _this$props.onMouseDown,
          onPathInit = _this$props.onPathInit,
          paper = _this$props.paper;

      if (toolEvent.event.button === MOUSE_LEFT_CODE$1) {
        var path = new paper.Path(pathProps);
        path.add(toolEvent.point);
        _this.path = path;
        onPathInit(path);
      }

      onMouseDown(toolEvent);
    };

    _this.onMouseDrag = function (toolEvent) {
      var _assertThisInitialize = _assertThisInitialized(_this),
          path = _assertThisInitialize.path;

      var onMouseDrag = _this.props.onMouseDrag;

      if (toolEvent.event.buttons === 1) {
        path.removeSegment(1);
        path.addSegment(toolEvent.point);
        path.selected = true;
      }

      onMouseDrag(toolEvent);
    };

    _this.onMouseUp = function (toolEvent) {
      var _assertThisInitialize2 = _assertThisInitialized(_this),
          path = _assertThisInitialize2.path;

      var _this$props2 = _this.props,
          onMouseUp = _this$props2.onMouseUp,
          onPathAdd = _this$props2.onPathAdd;

      if (path) {
        path.selected = false;
        onPathAdd(path);
        _this.path = null;
      }

      onMouseUp(toolEvent);
    };

    return _this;
  }

  _createClass(LineTool, [{
    key: "render",
    value: function render() {
      var _this$props3 = this.props,
          pathProps = _this$props3.pathProps,
          onMouseDown = _this$props3.onMouseDown,
          onMouseDrag = _this$props3.onMouseDrag,
          onMouseUp = _this$props3.onMouseUp,
          onPathAdd = _this$props3.onPathAdd,
          innerRef = _this$props3.innerRef,
          rest = _objectWithoutProperties(_this$props3, ["pathProps", "onMouseDown", "onMouseDrag", "onMouseUp", "onPathAdd", "innerRef"]);

      return /*#__PURE__*/React.createElement(Tool$1, _extends({
        ref: innerRef,
        onMouseDown: this.onMouseDown,
        onMouseDrag: this.onMouseDrag,
        onMouseUp: this.onMouseUp
      }, rest));
    }
  }]);

  return LineTool;
}(PathTool), _class2$1.defaultProps = _objectSpread2(_objectSpread2({}, PathTool.defaultProps), {}, {
  pathProps: {
    strokeColor: 'black'
  }
}), _temp$1)) || _class$1;

var LineTool_component = React.forwardRef(function (props, ref) {
  return /*#__PURE__*/React.createElement(LineTool, _extends({
    innerRef: ref
  }, props));
});

var _class$2, _class2$2, _temp$2;
var Tool$2 = ReactPaperJS.Tool,
    PaperScope$2 = ReactPaperJS.PaperScope;
var MOUSE_LEFT_CODE$2 = 0; // $FlowFixMe

var PolygonTool = PaperScope$2(_class$2 = (_temp$2 = _class2$2 = /*#__PURE__*/function (_PathTool) {
  _inherits(PolygonTool, _PathTool);

  var _super = _createSuper(PolygonTool);

  function PolygonTool() {
    var _this;

    _classCallCheck(this, PolygonTool);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _this.onMouseDown = function (toolEvent) {
      if (toolEvent.event.button === MOUSE_LEFT_CODE$2) {
        var _assertThisInitialize = _assertThisInitialized(_this),
            path = _assertThisInitialize.path;

        if (!path) {
          _this.pathInit();

          _this.props.onPathInit(path);
        }

        if (_this.selectedSegment == null) {
          _this.onSegmentAdd(toolEvent);
        } else {
          _this.onPathAdd();
        }
      }

      _this.props.onMouseDown(toolEvent);
    };

    _this.points = void 0;
    _this.selectedSegment = void 0;
    return _this;
  }

  _createClass(PolygonTool, [{
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      var path = this.path,
          points = this.points,
          props = this.props;
      var pathProps = props.pathProps,
          pathData = props.pathData;

      if (path) {
        this.setPathData(pathData);
        Object.assign(path, pathProps);
      } else if (points) {
        this.pathInit();
      }
    }
  }, {
    key: "pathInit",
    value: function pathInit() {
      var _this$props = this.props,
          pathProps = _this$props.pathProps,
          pathData = _this$props.pathData,
          paper = _this$props.paper;
      var Path = paper.Path;
      var path = new Path(pathProps);
      this.path = path;
      this.setPathData(pathData);
    }
  }, {
    key: "setPathData",
    value: function setPathData(pathData) {
      var _this2 = this;

      var path = this.path;
      this.removeBounds();
      path.pathData = pathData;
      path.segments.forEach(function (segment) {
        return _this2.createBounds(segment);
      });
    }
  }, {
    key: "onSegmentAdd",
    value: function onSegmentAdd(toolEvent) {
      var path = this.path;
      path.add(toolEvent.point);
      var segment = path.lastSegment;
      this.createBounds(segment);
      this.props.onSegmentAdd(segment, path);
    }
  }, {
    key: "onPathAdd",
    value: function onPathAdd() {
      var selectedSegment = this.selectedSegment,
          path = this.path,
          points = this.points;
      var _this$props2 = this.props,
          onSegmentRemove = _this$props2.onSegmentRemove,
          onPathAdd = _this$props2.onPathAdd;
      var index = selectedSegment.index;
      var segments = path.removeSegments(0, index);

      if (segments.length) {
        onSegmentRemove(segments, path);
      }

      path.closed = true;
      path.selected = false;
      onPathAdd(path);
      this.path = null;
      this.selectedSegment = null;

      if (points) {
        points.remove();
      }
    }
  }, {
    key: "createBounds",
    value: function createBounds(segment) {
      var _this3 = this;

      var paper = this.props.paper;
      var Path = paper.Path,
          Group = paper.Group,
          project = paper.project;
      var path = this.path,
          points = this.points;

      if (!points) {
        this.points = new Group();
        project.layers.$$metadata.addChild(this.points);
      }

      var bounds = new Path.Circle({
        center: segment.point,
        radius: 7,
        fillColor: 'white',
        opacity: 0
      });
      bounds.on('mousedown', function () {
        if (!path.closed && !path.lastSegment.point.equals(bounds.position) && path.contains(bounds.position)) {
          _this3.selectedSegment = segment;
        }
      });
      this.points.addChild(bounds);
    }
  }, {
    key: "removeBounds",
    value: function removeBounds() {
      if (this.points) {
        this.points.remove();
        this.points = null;
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props3 = this.props,
          pathProps = _this$props3.pathProps,
          onMouseDown = _this$props3.onMouseDown,
          onPathAdd = _this$props3.onPathAdd,
          onSegmentAdd = _this$props3.onSegmentAdd,
          onSegmentRemove = _this$props3.onSegmentRemove,
          paper = _this$props3.paper,
          innerRef = _this$props3.innerRef,
          rest = _objectWithoutProperties(_this$props3, ["pathProps", "onMouseDown", "onPathAdd", "onSegmentAdd", "onSegmentRemove", "paper", "innerRef"]);

      return /*#__PURE__*/React.createElement(Tool$2, _extends({
        ref: innerRef,
        onMouseDown: this.onMouseDown
      }, rest));
    }
  }]);

  return PolygonTool;
}(PathTool), _class2$2.defaultProps = _objectSpread2(_objectSpread2({}, PathTool.defaultProps), {}, {
  pathProps: {
    strokeColor: 'black',
    selected: true
  }
}), _temp$2)) || _class$2;

var PolygonTool_component = React.forwardRef(function (props, ref) {
  return /*#__PURE__*/React.createElement(PolygonTool, _extends({
    innerRef: ref
  }, props));
});

var _class$3, _class2$3, _temp$3;
var Tool$3 = ReactPaperJS.Tool,
    PaperScope$3 = ReactPaperJS.PaperScope;
var MOUSE_LEFT_CODE$3 = 0; // $FlowFixMe

var RectangleTool = PaperScope$3(_class$3 = (_temp$3 = _class2$3 = /*#__PURE__*/function (_PathTool) {
  _inherits(RectangleTool, _PathTool);

  var _super = _createSuper(RectangleTool);

  function RectangleTool() {
    var _this;

    _classCallCheck(this, RectangleTool);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _this.onMouseDown = function (toolEvent) {
      var _this$props = _this.props,
          pathProps = _this$props.pathProps,
          onMouseDown = _this$props.onMouseDown,
          onPathInit = _this$props.onPathInit,
          paper = _this$props.paper;

      if (toolEvent.event.button === MOUSE_LEFT_CODE$3) {
        var Path = paper.Path,
            Color = paper.Color;
        var start = toolEvent.point;
        var path = new Path.Rectangle({
          point: start,
          size: [1, 1],
          fillColor: pathProps.selectedFillColor || new Color(0.9, 0.9, 1, 0.75),
          selected: true
        });
        _this.path = path;
        _this.start = start;
        onPathInit(path);
      }

      onMouseDown(toolEvent);
    };

    _this.onMouseDrag = function (toolEvent) {
      var onMouseDrag = _this.props.onMouseDrag;

      if (toolEvent.event.buttons === 1) {
        var _assertThisInitialize = _assertThisInitialized(_this),
            path = _assertThisInitialize.path,
            start = _assertThisInitialize.start;

        var bounds = path.bounds;
        var offset = toolEvent.point.subtract(start);
        var width = Math.abs(offset.x);
        var height = Math.abs(offset.y);

        if (offset.x < 0) {
          bounds.left = toolEvent.point.x;
          bounds.right = start.x;
        } else {
          bounds.left = start.x;
        }

        if (offset.y > 0) {
          bounds.top = start.y;
          bounds.bottom = toolEvent.point.y;
        } else {
          bounds.top = toolEvent.point.y;
        }

        if (width > 0) {
          bounds.width = width;
        }

        if (height > 0) {
          bounds.height = height;
        }
      }

      onMouseDrag(toolEvent);
    };

    _this.onMouseUp = function (event) {
      var _assertThisInitialize2 = _assertThisInitialized(_this),
          path = _assertThisInitialize2.path;

      var _this$props2 = _this.props,
          pathProps = _this$props2.pathProps,
          onMouseUp = _this$props2.onMouseUp,
          onPathAdd = _this$props2.onPathAdd;

      if (path) {
        Object.assign(path, _objectSpread2({
          selected: false
        }, pathProps));
        onPathAdd(path);
        _this.path = null;
        _this.start = null;
      }

      onMouseUp(event);
    };

    _this.start = void 0;
    return _this;
  }

  _createClass(RectangleTool, [{
    key: "render",
    value: function render() {
      var _this$props3 = this.props,
          innerRef = _this$props3.innerRef,
          rest = _objectWithoutProperties(_this$props3, ["innerRef"]);

      return /*#__PURE__*/React.createElement(Tool$3, _extends({}, rest, {
        ref: innerRef,
        onMouseDown: this.onMouseDown,
        onMouseDrag: this.onMouseDrag,
        onMouseUp: this.onMouseUp
      }));
    }
  }]);

  return RectangleTool;
}(PathTool), _class2$3.defaultProps = _objectSpread2(_objectSpread2({}, PathTool.defaultProps), {}, {
  pathProps: {
    fillColor: 'white',
    strokeColor: 'black'
  }
}), _temp$3)) || _class$3;

var RectangleTool_component = React.forwardRef(function (props, ref) {
  return /*#__PURE__*/React.createElement(RectangleTool, _extends({
    innerRef: ref
  }, props));
});

var _class$4, _class2$4, _temp$4;
var Tool$4 = ReactPaperJS.Tool,
    PaperScope$4 = ReactPaperJS.PaperScope;
var MOUSE_LEFT_CODE$4 = 0; // $FlowFixMe

var CircleTool = PaperScope$4(_class$4 = (_temp$4 = _class2$4 = /*#__PURE__*/function (_PathTool) {
  _inherits(CircleTool, _PathTool);

  var _super = _createSuper(CircleTool);

  function CircleTool() {
    var _this;

    _classCallCheck(this, CircleTool);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _this.onMouseDown = function (toolEvent) {
      var _this$props = _this.props,
          pathProps = _this$props.pathProps,
          onMouseDown = _this$props.onMouseDown,
          onPathInit = _this$props.onPathInit,
          paper = _this$props.paper;

      if (toolEvent.event.button === MOUSE_LEFT_CODE$4) {
        var Path = paper.Path,
            Color = paper.Color;
        var path = new Path.Circle({
          center: toolEvent.point,
          radius: 1,
          fillColor: pathProps.selectedFillColor || new Color(0.9, 0.9, 1, 0.75),
          selected: true
        });
        _this.path = path;
        onPathInit(path);
      }

      onMouseDown(toolEvent);
    };

    _this.onMouseDrag = function (toolEvent) {
      var onMouseDrag = _this.props.onMouseDrag;

      if (toolEvent.event.buttons === 1) {
        var _assertThisInitialize = _assertThisInitialized(_this),
            path = _assertThisInitialize.path;

        var scale = Math.abs(toolEvent.point.getDistance(path.position) / (path.bounds.width / 2));

        if (scale > 0.1) {
          path.scale(scale);
        }
      }

      onMouseDrag(toolEvent);
    };

    _this.onMouseUp = function (event) {
      var _assertThisInitialize2 = _assertThisInitialized(_this),
          path = _assertThisInitialize2.path;

      var _this$props2 = _this.props,
          pathProps = _this$props2.pathProps,
          onMouseUp = _this$props2.onMouseUp,
          onPathAdd = _this$props2.onPathAdd;

      if (path) {
        Object.assign(path, _objectSpread2({
          selected: false
        }, pathProps));
        onPathAdd(path);
        _this.path = null;
      }

      onMouseUp(event);
    };

    return _this;
  }

  _createClass(CircleTool, [{
    key: "render",
    value: function render() {
      var _this$props3 = this.props,
          innerRef = _this$props3.innerRef,
          rest = _objectWithoutProperties(_this$props3, ["innerRef"]);

      return /*#__PURE__*/React.createElement(Tool$4, _extends({
        ref: innerRef
      }, rest, {
        onMouseDown: this.onMouseDown,
        onMouseDrag: this.onMouseDrag,
        onMouseUp: this.onMouseUp
      }));
    }
  }]);

  return CircleTool;
}(PathTool), _class2$4.defaultProps = _objectSpread2(_objectSpread2({}, PathTool.defaultProps), {}, {
  pathProps: {
    fillColor: 'white',
    strokeColor: 'black'
  }
}), _temp$4)) || _class$4;

var CircleTool_component = React.forwardRef(function (props, ref) {
  return /*#__PURE__*/React.createElement(CircleTool, _extends({
    innerRef: ref
  }, props));
});

var _class$5, _class2$5, _temp$5;
var Tool$5 = ReactPaperJS.Tool,
    PaperScope$5 = ReactPaperJS.PaperScope;
var MOUSE_LEFT_CODE$5 = 0; // $FlowFixMe

var SegmentPathTool = PaperScope$5(_class$5 = (_temp$5 = _class2$5 = /*#__PURE__*/function (_PathTool) {
  _inherits(SegmentPathTool, _PathTool);

  var _super = _createSuper(SegmentPathTool);

  function SegmentPathTool() {
    var _this;

    _classCallCheck(this, SegmentPathTool);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _this.onKeyUp = function () {
      var _assertThisInitialize = _assertThisInitialized(_this),
          path = _assertThisInitialize.path,
          onPathAdd = _assertThisInitialize.onPathAdd;

      if (path) {
        if (path.segments.length > 1) {
          onPathAdd();
        } else {
          path.remove();
          _this.path = null;
        }
      }
    };

    _this.onMouseDown = function (toolEvent) {
      var _assertThisInitialize2 = _assertThisInitialized(_this),
          path = _assertThisInitialize2.path;

      if (toolEvent.event.button === MOUSE_LEFT_CODE$5 && toolEvent.modifiers.shift) {
        if (!path) {
          _this.pathInit();

          _this.props.onPathInit(path);
        }

        _this.onSegmentAdd(toolEvent);
      }

      _this.props.onMouseDown(toolEvent);
    };

    _this.onPathAdd = function () {
      var _assertThisInitialize3 = _assertThisInitialized(_this),
          path = _assertThisInitialize3.path;

      var onPathAdd = _this.props.onPathAdd;
      path.selected = false;
      onPathAdd(path);
      _this.path = null;
    };

    return _this;
  }

  _createClass(SegmentPathTool, [{
    key: "pathInit",
    value: function pathInit() {
      var _this$props = this.props,
          pathProps = _this$props.pathProps,
          pathData = _this$props.pathData,
          paper = _this$props.paper;
      var Path = paper.Path;
      var path = new Path(pathProps);
      this.path = path;
      this.setPathData(pathData);
    }
  }, {
    key: "setPathData",
    value: function setPathData(pathData) {
      this.path.pathData = pathData;
    }
  }, {
    key: "onSegmentAdd",
    value: function onSegmentAdd(toolEvent) {
      var path = this.path;
      path.add(toolEvent.point);
      this.props.onSegmentAdd(path.lastSegment, path);
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props2 = this.props,
          pathProps = _this$props2.pathProps,
          onKeyUp = _this$props2.onKeyUp,
          onMouseDown = _this$props2.onMouseDown,
          onPathAdd = _this$props2.onPathAdd,
          onSegmentAdd = _this$props2.onSegmentAdd,
          onSegmentRemove = _this$props2.onSegmentRemove,
          paper = _this$props2.paper,
          innerRef = _this$props2.innerRef,
          rest = _objectWithoutProperties(_this$props2, ["pathProps", "onKeyUp", "onMouseDown", "onPathAdd", "onSegmentAdd", "onSegmentRemove", "paper", "innerRef"]);

      return /*#__PURE__*/React.createElement(Tool$5, _extends({
        ref: innerRef,
        onKeyUp: this.onKeyUp,
        onMouseDown: this.onMouseDown
      }, rest));
    }
  }]);

  return SegmentPathTool;
}(PathTool), _class2$5.defaultProps = _objectSpread2(_objectSpread2({}, PathTool.defaultProps), {}, {
  pathProps: {
    strokeColor: 'black',
    selected: true
  }
}), _temp$5)) || _class$5;

var SegmentPathTool_component = React.forwardRef(function (props, ref) {
  return /*#__PURE__*/React.createElement(SegmentPathTool, _extends({
    innerRef: ref
  }, props));
});

var _class$6, _class2$6, _temp$6;
var PaperScope$6 = ReactPaperJS.PaperScope,
    getProps = ReactPaperJS.getProps;

function add(num1, num2) {
  return (num1 * 10 + num2 * 10) / 10;
}

function callAllHandlers() {
  var handlers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  return function (event) {
    return handlers.forEach(function (handler) {
      return handler && handler(event);
    });
  };
} // $FlowFixMe


var PanAndScroll = PaperScope$6(_class$6 = (_temp$6 = _class2$6 = /*#__PURE__*/function (_React$Component) {
  _inherits(PanAndScroll, _React$Component);

  var _super = _createSuper(PanAndScroll);

  function PanAndScroll(_props) {
    var _this;

    _classCallCheck(this, PanAndScroll);

    _this = _super.call(this, _props);

    _this.onWheel = function (_ref) {
      var deltaY = _ref.deltaY;
      var _this$props = _this.props,
          onZoom = _this$props.onZoom,
          mergeProps = _this$props.mergeProps;
      mergeProps(function (state, props) {
        var zoom = state.viewProps.zoom;

        if (deltaY < 0) {
          zoom = add(zoom, 0.1);
          if (onZoom) onZoom(zoom);
          return {
            viewProps: _objectSpread2(_objectSpread2(_objectSpread2({}, props.viewProps), state.viewProps), {}, {
              zoom: zoom
            })
          };
        }

        if (deltaY > 0 && zoom > 0.1) {
          zoom = add(zoom, -0.1);
          if (onZoom) onZoom(zoom);
          return {
            viewProps: _objectSpread2(_objectSpread2(_objectSpread2({}, props.viewProps), state.viewProps), {}, {
              zoom: zoom
            })
          };
        }

        return null;
      });
    };

    _this.onKeyDown = function (_ref2) {
      var key = _ref2.key;
      var draggable = _this.state.draggable;

      if (key === 'space' && !draggable) {
        var _this$props2 = _this.props,
            onPanEnabled = _this$props2.onPanEnabled,
            mergeProps = _this$props2.mergeProps;
        mergeProps(function (state, props) {
          return _objectSpread2(_objectSpread2({}, state), {}, {
            canvasProps: _objectSpread2(_objectSpread2(_objectSpread2({}, props.canvasProps), state.canvasProps), {}, {
              'drag-state': 'enabled'
            })
          });
        });

        _this.setState({
          draggable: true
        });

        if (onPanEnabled) onPanEnabled();
      }
    };

    _this.onKeyUp = function (_ref3) {
      var key = _ref3.key;

      if (key === 'space') {
        var _this$props3 = _this.props,
            onPanDisabled = _this$props3.onPanDisabled,
            mergeProps = _this$props3.mergeProps;
        mergeProps(function (state, props) {
          return _objectSpread2(_objectSpread2({}, state), {}, {
            canvasProps: _objectSpread2(_objectSpread2(_objectSpread2({}, props.canvasProps), state.canvasProps), {}, {
              'drag-state': 'disabled'
            })
          });
        });

        _this.setState({
          draggable: false
        });

        if (onPanDisabled) onPanDisabled();
      }
    };

    _this.onMouseDown = function (_ref4) {
      var point = _ref4.point;
      var _this$state = _this.state,
          draggable = _this$state.draggable,
          dragStart = _this$state.dragStart;

      if (draggable && !dragStart) {
        var mergeProps = _this.props.mergeProps;
        mergeProps(function (state, props) {
          return _objectSpread2(_objectSpread2({}, state), {}, {
            canvasProps: _objectSpread2(_objectSpread2(_objectSpread2({}, props.canvasProps), state.canvasProps), {}, {
              'drag-state': 'dragging'
            })
          });
        });

        _this.setState({
          dragStart: point
        });
      }
    };

    _this.onMouseUp = function () {
      var _this$state2 = _this.state,
          dragStart = _this$state2.dragStart,
          draggable = _this$state2.draggable;

      if (dragStart) {
        if (draggable) {
          var mergeProps = _this.props.mergeProps;
          mergeProps(function (state, props) {
            return _objectSpread2(_objectSpread2({}, state), {}, {
              canvasProps: _objectSpread2(_objectSpread2(_objectSpread2({}, props.canvasProps), state.canvasProps), {}, {
                'drag-state': 'enabled'
              })
            });
          });
        }

        _this.setState({
          dragStart: null
        });
      }
    };

    _this.onMouseDrag = function (_ref5) {
      var point = _ref5.point;
      var _this$props4 = _this.props,
          mergeProps = _this$props4.mergeProps,
          paper = _this$props4.paper;
      var _this$state3 = _this.state,
          draggable = _this$state3.draggable,
          dragStart = _this$state3.dragStart;
      mergeProps(function (state, props) {
        if (dragStart) {
          return {
            viewProps: _objectSpread2(_objectSpread2(_objectSpread2({}, props.viewProps), state.viewProps), {}, {
              center: paper.view.center.add(point.subtract(dragStart).multiply(0.5))
            })
          };
        }

        return null;
      });

      if (draggable) {
        _this.setState({
          dragStart: point
        });
      }
    };

    _this.state = {
      draggable: false,
      dragStart: null
    };
    return _this;
  }

  _createClass(PanAndScroll, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this2 = this;

      var _this$props5 = this.props,
          paper = _this$props5.paper,
          zoomLevel = _this$props5.zoomLevel,
          center = _this$props5.center,
          mergeProps = _this$props5.mergeProps;
      mergeProps(function (state, props) {
        var _getProps = getProps(paper, props.canvasProps),
            onWheel = _getProps.onWheel,
            canvasProps = _objectWithoutProperties(_getProps, ["onWheel"]);

        var _getProps2 = getProps(paper, props.viewProps),
            onKeyDown = _getProps2.onKeyDown,
            onKeyUp = _getProps2.onKeyUp,
            onMouseDown = _getProps2.onMouseDown,
            onMouseDrag = _getProps2.onMouseDrag,
            onMouseUp = _getProps2.onMouseUp,
            viewProps = _objectWithoutProperties(_getProps2, ["onKeyDown", "onKeyUp", "onMouseDown", "onMouseDrag", "onMouseUp"]);

        return {
          canvasProps: _objectSpread2(_objectSpread2({}, canvasProps), {}, {
            onWheel: callAllHandlers([onWheel, _this2.onWheel]),
            'drag-state': 'disabled'
          }),
          viewProps: _objectSpread2(_objectSpread2({}, viewProps), {}, {
            onKeyDown: callAllHandlers([onKeyDown, _this2.onKeyDown]),
            onKeyUp: callAllHandlers([onKeyUp, _this2.onKeyUp]),
            onMouseDown: callAllHandlers([onMouseDown, _this2.onMouseDown]),
            onMouseDrag: callAllHandlers([onMouseDrag, _this2.onMouseDrag]),
            onMouseUp: callAllHandlers([onMouseUp, _this2.onMouseUp]),
            zoom: zoomLevel,
            center: center
          })
        };
      });
    }
  }, {
    key: "render",
    value: function render() {
      var children = this.props.children;
      return children;
    }
  }]);

  return PanAndScroll;
}(React.Component), _class2$6.defaultProps = {
  zoomLevel: 1,
  onPanEnabled: function onPanEnabled() {},
  onPanDisabled: function onPanDisabled() {},
  onZoom: function onZoom() {}
}, _temp$6)) || _class$6;

var _class$7, _class2$7, _temp$7;
var Tool$6 = ReactPaperJS.Tool,
    PaperScope$7 = ReactPaperJS.PaperScope;
var MOUSE_LEFT_CODE$6 = 0; // $FlowFixMe

var EllipseTool = PaperScope$7(_class$7 = (_temp$7 = _class2$7 = /*#__PURE__*/function (_PathTool) {
  _inherits(EllipseTool, _PathTool);

  var _super = _createSuper(EllipseTool);

  function EllipseTool() {
    var _this;

    _classCallCheck(this, EllipseTool);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _this.onMouseDown = function (toolEvent) {
      var _this$props = _this.props,
          pathProps = _this$props.pathProps,
          onMouseDown = _this$props.onMouseDown,
          onPathInit = _this$props.onPathInit,
          paper = _this$props.paper;

      if (toolEvent.event.button === MOUSE_LEFT_CODE$6) {
        var Path = paper.Path,
            Color = paper.Color;
        var start = toolEvent.point;
        var path = new Path.Ellipse({
          point: start,
          size: [1, 1],
          fillColor: pathProps.selectedFillColor || new Color(0.9, 0.9, 1, 0.75),
          selected: true
        });
        _this.path = path;
        _this.start = start;
        onPathInit(_this.path);
      }

      onMouseDown(toolEvent);
    };

    _this.onMouseDrag = function (toolEvent) {
      var onMouseDrag = _this.props.onMouseDrag;

      if (toolEvent.event.buttons === 1) {
        var _assertThisInitialize = _assertThisInitialized(_this),
            path = _assertThisInitialize.path,
            start = _assertThisInitialize.start;

        var bounds = path.bounds;
        var offset = toolEvent.point.subtract(start);
        var width = Math.abs(offset.x);
        var height = Math.abs(offset.y);

        if (offset.x < 0) {
          bounds.left = toolEvent.point.x;
          bounds.right = start.x;
        } else {
          bounds.left = start.x;
        }

        if (offset.y > 0) {
          bounds.top = start.y;
          bounds.bottom = toolEvent.point.y;
        } else {
          bounds.top = toolEvent.point.y;
        }

        if (width > 0) {
          bounds.width = width;
        }

        if (height > 0) {
          bounds.height = height;
        }
      }

      onMouseDrag(toolEvent);
    };

    _this.onMouseUp = function (event) {
      var _assertThisInitialize2 = _assertThisInitialized(_this),
          path = _assertThisInitialize2.path;

      var _this$props2 = _this.props,
          pathProps = _this$props2.pathProps,
          onMouseUp = _this$props2.onMouseUp,
          onPathAdd = _this$props2.onPathAdd;

      if (path) {
        Object.assign(path, _objectSpread2({
          selected: false
        }, pathProps));
        onPathAdd(path);
        _this.path = null;
        _this.start = null;
      }

      onMouseUp(event);
    };

    _this.start = void 0;
    return _this;
  }

  _createClass(EllipseTool, [{
    key: "render",
    value: function render() {
      var _this$props3 = this.props,
          innerRef = _this$props3.innerRef,
          rest = _objectWithoutProperties(_this$props3, ["innerRef"]);

      return /*#__PURE__*/React.createElement(Tool$6, _extends({}, rest, {
        ref: innerRef,
        onMouseDown: this.onMouseDown,
        onMouseDrag: this.onMouseDrag,
        onMouseUp: this.onMouseUp
      }));
    }
  }]);

  return EllipseTool;
}(PathTool), _class2$7.defaultProps = _objectSpread2(_objectSpread2({}, PathTool.defaultProps), {}, {
  pathProps: {
    fillColor: 'white',
    strokeColor: 'black'
  }
}), _temp$7)) || _class$7;

var EllipseTool_component = React.forwardRef(function (props, ref) {
  return /*#__PURE__*/React.createElement(EllipseTool, _extends({
    innerRef: ref
  }, props));
});

exports.CircleTool = CircleTool_component;
exports.EllipseTool = EllipseTool_component;
exports.FreeformPathTool = FreeformPathTool_component;
exports.Grid = Grid_component;
exports.LineTool = LineTool_component;
exports.PanAndZoom = PanAndScroll;
exports.PathTool = PathTool;
exports.PolygonTool = PolygonTool_component;
exports.RectangleTool = RectangleTool_component;
exports.SegmentPathTool = SegmentPathTool_component;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguZGV2LmpzIiwic291cmNlcyI6WyIuLi9zcmMvY29tcG9uZW50cy9zaGFyZWQvUGF0aFRvb2wvUGF0aFRvb2wuY29tcG9uZW50LmpzIiwiLi4vc3JjL2NvbXBvbmVudHMvRnJlZWZvcm1QYXRoVG9vbC9GcmVlZm9ybVBhdGhUb29sLmNvbXBvbmVudC5qcyIsIi4uL3NyYy9jb21wb25lbnRzL0dyaWQvR3JpZC5jb21wb25lbnQuanMiLCIuLi9zcmMvY29tcG9uZW50cy9MaW5lVG9vbC9MaW5lVG9vbC5jb21wb25lbnQuanMiLCIuLi9zcmMvY29tcG9uZW50cy9Qb2x5Z29uVG9vbC9Qb2x5Z29uVG9vbC5jb21wb25lbnQuanMiLCIuLi9zcmMvY29tcG9uZW50cy9SZWN0YW5nbGVUb29sL1JlY3RhbmdsZVRvb2wuY29tcG9uZW50LmpzIiwiLi4vc3JjL2NvbXBvbmVudHMvQ2lyY2xlVG9vbC9DaXJjbGVUb29sLmNvbXBvbmVudC5qcyIsIi4uL3NyYy9jb21wb25lbnRzL1NlZ21lbnRQYXRoVG9vbC9TZWdtZW50UGF0aFRvb2wuY29tcG9uZW50LmpzIiwiLi4vc3JjL2NvbXBvbmVudHMvUGFuQW5kWm9vbS9QYW5BbmRab29tLmNvbXBvbmVudC5qcyIsIi4uL3NyYy9jb21wb25lbnRzL0VsbGlwc2VUb29sL0VsbGlwc2VUb29sLmNvbXBvbmVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAZmxvd1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHR5cGUgeyBUb29sRXZlbnRIYW5kbGVyIH0gZnJvbSAnQHBzeWNob2JvbHQvcmVhY3QtcGFwZXJqcyc7XG5pbXBvcnQgdHlwZW9mIHsgUGFwZXJTY29wZSwgUGF0aCwgU2VnbWVudCwgS2V5RXZlbnQgfSBmcm9tICdwYXBlcic7XG5cbnR5cGUgS2V5RXZlbnRIYW5kbGVyID0gKGV2ZW50OiBLZXlFdmVudCkgPT4gYW55XG50eXBlIFBhdGhFdmVudEhhbmRsZXIgPSAocGF0aDogUGF0aCkgPT4gYW55XG50eXBlIFNlZ21lbnRFdmVudEhhbmRsZXIgPSAoc2VnbWVudDogU2VnbWVudCB8IFNlZ21lbnRbXSkgPT4gYW55O1xuXG50eXBlIFByb3BzID0ge1xuICBwYXBlcjogUGFwZXJTY29wZSxcbiAgb25LZXlEb3duOiBLZXlFdmVudEhhbmRsZXIsXG4gIG9uS2V5VXA6IEtleUV2ZW50SGFuZGxlcixcbiAgb25Nb3VzZURvd246IFRvb2xFdmVudEhhbmRsZXIsXG4gIG9uTW91c2VEcmFnOiBUb29sRXZlbnRIYW5kbGVyLFxuICBvbk1vdXNlVXA6IFRvb2xFdmVudEhhbmRsZXIsXG4gIG9uUGF0aEluaXQ6IFBhdGhFdmVudEhhbmRsZXIsXG4gIG9uUGF0aEFkZDogUGF0aEV2ZW50SGFuZGxlcixcbiAgb25TZWdtZW50QWRkOiBTZWdtZW50RXZlbnRIYW5kbGVyLFxuICBvblNlZ21lbnRSZW1vdmU6IFNlZ21lbnRFdmVudEhhbmRsZXJcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBhdGhUb29sPFA+IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PFAgJiBQcm9wcz4ge1xuICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgIG9uS2V5RG93bjogKCkgPT4ge30sXG4gICAgb25LZXlVcDogKCkgPT4ge30sXG4gICAgb25Nb3VzZURvd246ICgpID0+IHt9LFxuICAgIG9uTW91c2VEcmFnOiAoKSA9PiB7fSxcbiAgICBvbk1vdXNlVXA6ICgpID0+IHt9LFxuICAgIG9uUGF0aEluaXQ6ICgpID0+IHt9LFxuICAgIG9uUGF0aEFkZDogKCkgPT4ge30sXG4gICAgb25TZWdtZW50QWRkOiAoKSA9PiB7fSxcbiAgICBvblNlZ21lbnRSZW1vdmU6ICgpID0+IHt9LFxuICB9XG5cbiAgcGF0aDogUGF0aFxufVxuIiwiLy8gQGZsb3dcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCAqIGFzIFJlYWN0UGFwZXJKUyBmcm9tICdAcHN5Y2hvYm9sdC9yZWFjdC1wYXBlcmpzJztcbmltcG9ydCB0eXBlb2YgeyBUb29sRXZlbnQsIFRvb2wgYXMgVG9vbFR5cGUgfSBmcm9tICdwYXBlcic7XG5cblxuaW1wb3J0IFBhdGhUb29sIGZyb20gJy4uL3NoYXJlZC9QYXRoVG9vbCc7XG5cbmNvbnN0IHsgVG9vbCwgUGFwZXJTY29wZSB9ID0gUmVhY3RQYXBlckpTO1xuXG50eXBlIFByb3BzID0ge1xuICBwYXRoUHJvcHM6IHtcbiAgICBzdHJva2VDb2xvcjogc3RyaW5nLFxuICB9LFxuICBpbm5lclJlZjogUmVhY3QuUmVmPFRvb2xUeXBlPlxufTtcblxuY29uc3QgTU9VU0VfTEVGVF9DT0RFID0gMDtcblxuLy8gJEZsb3dGaXhNZVxuQFBhcGVyU2NvcGVcbmNsYXNzIEZyZWVmb3JtUGF0aFRvb2wgZXh0ZW5kcyBQYXRoVG9vbDxQcm9wcz4ge1xuICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgIC4uLlBhdGhUb29sLmRlZmF1bHRQcm9wcyxcbiAgICBwYXRoUHJvcHM6IHtcbiAgICAgIHN0cm9rZUNvbG9yOiAnYmxhY2snLFxuICAgIH0sXG4gIH1cblxuICBvbk1vdXNlRG93biA9ICh0b29sRXZlbnQ6IFRvb2xFdmVudCkgPT4ge1xuICAgIGNvbnN0IHsgcGF0aFByb3BzLCBvbk1vdXNlRG93biwgb25QYXRoSW5pdCwgcGFwZXIgfSA9IHRoaXMucHJvcHM7XG4gICAgaWYgKHRvb2xFdmVudC5ldmVudC5idXR0b24gPT09IE1PVVNFX0xFRlRfQ09ERSkge1xuICAgICAgY29uc3QgcGF0aCA9IG5ldyBwYXBlci5QYXRoKHBhdGhQcm9wcyk7XG4gICAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgICAgb25QYXRoSW5pdChwYXRoKTtcbiAgICB9XG4gICAgb25Nb3VzZURvd24odG9vbEV2ZW50KTtcbiAgfVxuXG4gIG9uTW91c2VEcmFnID0gKHRvb2xFdmVudDogVG9vbEV2ZW50KSA9PiB7XG4gICAgY29uc3QgeyBvbk1vdXNlRHJhZyB9ID0gdGhpcy5wcm9wcztcbiAgICBpZiAodG9vbEV2ZW50LmV2ZW50LmJ1dHRvbnMgPT09IDEpIHtcbiAgICAgIHRoaXMucGF0aC5hZGQodG9vbEV2ZW50LnBvaW50KTtcbiAgICB9XG4gICAgb25Nb3VzZURyYWcodG9vbEV2ZW50KTtcbiAgfVxuXG4gIG9uTW91c2VVcCA9ICh0b29sRXZlbnQ6IFRvb2xFdmVudCkgPT4ge1xuICAgIGNvbnN0IHsgcGF0aCB9ID0gdGhpcztcbiAgICBjb25zdCB7IG9uTW91c2VVcCwgb25QYXRoQWRkIH0gPSB0aGlzLnByb3BzO1xuICAgIGlmIChwYXRoKSB7XG4gICAgICBvblBhdGhBZGQocGF0aCk7XG4gICAgICB0aGlzLnBhdGggPSBudWxsO1xuICAgIH1cbiAgICBvbk1vdXNlVXAodG9vbEV2ZW50KTtcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBwYXRoUHJvcHMsIG9uTW91c2VEb3duLCBvbk1vdXNlRHJhZywgb25Nb3VzZVVwLCBvblBhdGhBZGQsIHBhcGVyLCBpbm5lclJlZiwgLi4ucmVzdFxuICAgIH0gPSB0aGlzLnByb3BzO1xuICAgIHJldHVybiAoXG4gICAgICA8VG9vbFxuICAgICAgICByZWY9e2lubmVyUmVmfVxuICAgICAgICBtaW5EaXN0YW5jZT17MTB9XG4gICAgICAgIG9uTW91c2VEb3duPXt0aGlzLm9uTW91c2VEb3dufVxuICAgICAgICBvbk1vdXNlRHJhZz17dGhpcy5vbk1vdXNlRHJhZ31cbiAgICAgICAgb25Nb3VzZVVwPXt0aGlzLm9uTW91c2VVcH1cbiAgICAgICAgey4uLnJlc3R9XG4gICAgICAvPlxuICAgICk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgUmVhY3RcbiAgLmZvcndhcmRSZWY8UHJvcHMsIFRvb2xUeXBlPigocHJvcHMsIHJlZikgPT4gPEZyZWVmb3JtUGF0aFRvb2wgaW5uZXJSZWY9e3JlZn0gey4uLnByb3BzfSAvPik7XG4iLCIvLyBAZmxvd1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0ICogYXMgUmVhY3RQYXBlckpTIGZyb20gJ0Bwc3ljaG9ib2x0L3JlYWN0LXBhcGVyanMnO1xuaW1wb3J0IHR5cGVvZiB7IExheWVyIGFzIExheWVyVHlwZSB9IGZyb20gJ3BhcGVyJztcblxuY29uc3QgeyBMYXllciwgR3JvdXAsIExpbmUgfSA9IFJlYWN0UGFwZXJKUztcblxudHlwZSBQcm9wcyA9IHtcbiAgdG9wOiBudW1iZXIsXG4gIGxlZnQ6IG51bWJlcixcbiAgcmlnaHQ6IG51bWJlcixcbiAgYm90dG9tOiBudW1iZXIsXG4gIHdpZHRoOiBudW1iZXIsXG4gIGhlaWdodDogbnVtYmVyLFxuICBjZWxsU2l6ZTogbnVtYmVyLFxuICBzdHJva2VDb2xvcjogc3RyaW5nLFxuICBzdHJva2VXaWR0aDogbnVtYmVyLFxuICBpbm5lclJlZjogUmVhY3QuUmVmPExheWVyVHlwZT5cbn07XG5cbmNvbnN0IEdyaWQgPSAoeyB3aWR0aCwgaGVpZ2h0LCB0b3AgPSAwLCBsZWZ0ID0gMCwgcmlnaHQgPSBsZWZ0ICsgd2lkdGgsIGJvdHRvbSA9IHRvcCArIGhlaWdodCwgY2VsbFNpemUgPSA1MCwgc3Ryb2tlQ29sb3IgPSAnI0QwRDBEMCcsIHN0cm9rZVdpZHRoID0gMSwgaW5uZXJSZWYgfTogUHJvcHMpID0+IHtcbiAgY29uc3QgeCA9IE1hdGguY2VpbChsZWZ0IC8gY2VsbFNpemUpICogY2VsbFNpemU7XG4gIGNvbnN0IHkgPSBNYXRoLmNlaWwodG9wIC8gY2VsbFNpemUpICogY2VsbFNpemU7XG4gIGNvbnN0IGNvbHMgPSBNYXRoLmNlaWwoKHJpZ2h0IC0gbGVmdCkgLyBjZWxsU2l6ZSk7XG4gIGNvbnN0IHJvd3MgPSBNYXRoLmNlaWwoKGJvdHRvbSAtIHRvcCkgLyBjZWxsU2l6ZSk7XG4gIGNvbnN0IHZlcnRpY2FsTGluZXMgPSBbXTtcbiAgY29uc3QgaG9yaXpvbnRhbExpbmVzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDw9IGNvbHM7IGkgKz0gMSkge1xuICAgIGNvbnN0IHBvc2l0aW9uID0geCArIChpICogY2VsbFNpemUpO1xuICAgIHZlcnRpY2FsTGluZXMucHVzaCg8TGluZVxuICAgICAga2V5PXtpfVxuICAgICAgZnJvbT17W3Bvc2l0aW9uLCB0b3BdfVxuICAgICAgdG89e1twb3NpdGlvbiwgYm90dG9tXX1cbiAgICAgIHN0cm9rZUNvbG9yPXtzdHJva2VDb2xvcn1cbiAgICAgIHN0cm9rZVdpZHRoPXtzdHJva2VXaWR0aH1cbiAgICAvPik7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPD0gcm93czsgaSArPSAxKSB7XG4gICAgY29uc3QgcG9zaXRpb24gPSB5ICsgKGkgKiBjZWxsU2l6ZSk7XG4gICAgaG9yaXpvbnRhbExpbmVzLnB1c2goPExpbmVcbiAgICAgIGtleT17aX1cbiAgICAgIGZyb209e1tsZWZ0LCBwb3NpdGlvbl19XG4gICAgICB0bz17W3JpZ2h0LCBwb3NpdGlvbl19XG4gICAgICBzdHJva2VDb2xvcj17c3Ryb2tlQ29sb3J9XG4gICAgICBzdHJva2VXaWR0aD17c3Ryb2tlV2lkdGh9XG4gICAgLz4pO1xuICB9XG4gIHJldHVybiAoXG4gICAgPExheWVyIHJlZj17aW5uZXJSZWZ9PlxuICAgICAgPEdyb3VwPlxuICAgICAgICB7dmVydGljYWxMaW5lc31cbiAgICAgIDwvR3JvdXA+XG4gICAgICA8R3JvdXA+XG4gICAgICAgIHtob3Jpem9udGFsTGluZXN9XG4gICAgICA8L0dyb3VwPlxuICAgIDwvTGF5ZXI+XG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBSZWFjdFxuICAuZm9yd2FyZFJlZjxQcm9wcywgTGF5ZXJUeXBlPigocHJvcHMsIHJlZikgPT4gPEdyaWQgaW5uZXJSZWY9e3JlZn0gey4uLnByb3BzfSAvPik7XG4iLCIvLyBAZmxvd1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0ICogYXMgUmVhY3RQYXBlckpTIGZyb20gJ0Bwc3ljaG9ib2x0L3JlYWN0LXBhcGVyanMnO1xuaW1wb3J0IHR5cGVvZiB7IFRvb2xFdmVudCwgVG9vbCBhcyBUb29sVHlwZSB9IGZyb20gJ3BhcGVyJztcblxuaW1wb3J0IFBhdGhUb29sIGZyb20gJy4uL3NoYXJlZC9QYXRoVG9vbCc7XG5cbmNvbnN0IHsgVG9vbCwgUGFwZXJTY29wZSB9ID0gUmVhY3RQYXBlckpTO1xuXG50eXBlIFByb3BzID0ge1xuICBwYXRoUHJvcHM6IHtcbiAgICBzdHJva2VDb2xvcjogc3RyaW5nLFxuICB9LFxuICBpbm5lclJlZjogUmVhY3QuUmVmPFRvb2xUeXBlPlxufTtcblxuY29uc3QgTU9VU0VfTEVGVF9DT0RFID0gMDtcblxuLy8gJEZsb3dGaXhNZVxuQFBhcGVyU2NvcGVcbmNsYXNzIExpbmVUb29sIGV4dGVuZHMgUGF0aFRvb2w8UHJvcHM+IHtcbiAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICAuLi5QYXRoVG9vbC5kZWZhdWx0UHJvcHMsXG4gICAgcGF0aFByb3BzOiB7XG4gICAgICBzdHJva2VDb2xvcjogJ2JsYWNrJyxcbiAgICB9LFxuICB9O1xuXG4gIG9uTW91c2VEb3duID0gKHRvb2xFdmVudDogVG9vbEV2ZW50KSA9PiB7XG4gICAgY29uc3QgeyBwYXRoUHJvcHMsIG9uTW91c2VEb3duLCBvblBhdGhJbml0LCBwYXBlciB9ID0gdGhpcy5wcm9wcztcbiAgICBpZiAodG9vbEV2ZW50LmV2ZW50LmJ1dHRvbiA9PT0gTU9VU0VfTEVGVF9DT0RFKSB7XG4gICAgICBjb25zdCBwYXRoID0gbmV3IHBhcGVyLlBhdGgocGF0aFByb3BzKTtcbiAgICAgIHBhdGguYWRkKHRvb2xFdmVudC5wb2ludCk7XG4gICAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgICAgb25QYXRoSW5pdChwYXRoKTtcbiAgICB9XG4gICAgb25Nb3VzZURvd24odG9vbEV2ZW50KTtcbiAgfVxuXG4gIG9uTW91c2VEcmFnID0gKHRvb2xFdmVudDogVG9vbEV2ZW50KSA9PiB7XG4gICAgY29uc3QgeyBwYXRoIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgb25Nb3VzZURyYWcgfSA9IHRoaXMucHJvcHM7XG4gICAgaWYgKHRvb2xFdmVudC5ldmVudC5idXR0b25zID09PSAxKSB7XG4gICAgICBwYXRoLnJlbW92ZVNlZ21lbnQoMSk7XG4gICAgICBwYXRoLmFkZFNlZ21lbnQodG9vbEV2ZW50LnBvaW50KTtcbiAgICAgIHBhdGguc2VsZWN0ZWQgPSB0cnVlO1xuICAgIH1cbiAgICBvbk1vdXNlRHJhZyh0b29sRXZlbnQpO1xuICB9XG5cbiAgb25Nb3VzZVVwID0gKHRvb2xFdmVudDogVG9vbEV2ZW50KSA9PiB7XG4gICAgY29uc3QgeyBwYXRoIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgb25Nb3VzZVVwLCBvblBhdGhBZGQgfSA9IHRoaXMucHJvcHM7XG4gICAgaWYgKHBhdGgpIHtcbiAgICAgIHBhdGguc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgIG9uUGF0aEFkZChwYXRoKTtcbiAgICAgIHRoaXMucGF0aCA9IG51bGw7XG4gICAgfVxuICAgIG9uTW91c2VVcCh0b29sRXZlbnQpO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHBhdGhQcm9wcywgb25Nb3VzZURvd24sIG9uTW91c2VEcmFnLCBvbk1vdXNlVXAsIG9uUGF0aEFkZCwgaW5uZXJSZWYsIC4uLnJlc3RcbiAgICB9ID0gdGhpcy5wcm9wcztcbiAgICByZXR1cm4gKFxuICAgICAgPFRvb2xcbiAgICAgICAgcmVmPXtpbm5lclJlZn1cbiAgICAgICAgb25Nb3VzZURvd249e3RoaXMub25Nb3VzZURvd259XG4gICAgICAgIG9uTW91c2VEcmFnPXt0aGlzLm9uTW91c2VEcmFnfVxuICAgICAgICBvbk1vdXNlVXA9e3RoaXMub25Nb3VzZVVwfVxuICAgICAgICB7Li4ucmVzdH1cbiAgICAgIC8+XG4gICAgKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBSZWFjdFxuICAuZm9yd2FyZFJlZjxQcm9wcywgVG9vbFR5cGU+KChwcm9wcywgcmVmKSA9PiA8TGluZVRvb2wgaW5uZXJSZWY9e3JlZn0gey4uLnByb3BzfSAvPik7XG4iLCIvLyBAZmxvd1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0ICogYXMgUmVhY3RQYXBlckpTIGZyb20gJ0Bwc3ljaG9ib2x0L3JlYWN0LXBhcGVyanMnO1xuaW1wb3J0IHR5cGVvZiB7IEdyb3VwIGFzIFBvaW50cywgU2VnbWVudCwgVG9vbEV2ZW50LCBUb29sIGFzIFRvb2xUeXBlIH0gZnJvbSAncGFwZXInO1xuXG5pbXBvcnQgUGF0aFRvb2wgZnJvbSAnLi4vc2hhcmVkL1BhdGhUb29sJztcblxuY29uc3QgeyBUb29sLCBQYXBlclNjb3BlIH0gPSBSZWFjdFBhcGVySlM7XG5cbnR5cGUgUHJvcHMgPSB7XG4gIHBhdGhQcm9wczoge1xuICAgIHN0cm9rZUNvbG9yOiBzdHJpbmcsXG4gIH0sXG4gIHBhdGhEYXRhOiBzdHJpbmcsXG4gIGlubmVyUmVmOiBSZWFjdC5SZWY8VG9vbFR5cGU+XG59O1xuXG5jb25zdCBNT1VTRV9MRUZUX0NPREUgPSAwO1xuXG4vLyAkRmxvd0ZpeE1lXG5AUGFwZXJTY29wZVxuY2xhc3MgUG9seWdvblRvb2wgZXh0ZW5kcyBQYXRoVG9vbDxQcm9wcz4ge1xuICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgIC4uLlBhdGhUb29sLmRlZmF1bHRQcm9wcyxcbiAgICBwYXRoUHJvcHM6IHtcbiAgICAgIHN0cm9rZUNvbG9yOiAnYmxhY2snLFxuICAgICAgc2VsZWN0ZWQ6IHRydWUsXG4gICAgfSxcbiAgfTtcblxuICBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgY29uc3QgeyBwYXRoLCBwb2ludHMsIHByb3BzIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgcGF0aFByb3BzLCBwYXRoRGF0YSB9ID0gcHJvcHM7XG4gICAgaWYgKHBhdGgpIHtcbiAgICAgIHRoaXMuc2V0UGF0aERhdGEocGF0aERhdGEpO1xuICAgICAgT2JqZWN0LmFzc2lnbihwYXRoLCBwYXRoUHJvcHMpO1xuICAgIH0gZWxzZSBpZiAocG9pbnRzKSB7XG4gICAgICB0aGlzLnBhdGhJbml0KCk7XG4gICAgfVxuICB9XG5cbiAgb25Nb3VzZURvd24gPSAodG9vbEV2ZW50OiBUb29sRXZlbnQpID0+IHtcbiAgICBpZiAodG9vbEV2ZW50LmV2ZW50LmJ1dHRvbiA9PT0gTU9VU0VfTEVGVF9DT0RFKSB7XG4gICAgICBjb25zdCB7IHBhdGggfSA9IHRoaXM7XG4gICAgICBpZiAoIXBhdGgpIHtcbiAgICAgICAgdGhpcy5wYXRoSW5pdCgpO1xuICAgICAgICB0aGlzLnByb3BzLm9uUGF0aEluaXQocGF0aCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zZWxlY3RlZFNlZ21lbnQgPT0gbnVsbCkge1xuICAgICAgICB0aGlzLm9uU2VnbWVudEFkZCh0b29sRXZlbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5vblBhdGhBZGQoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5wcm9wcy5vbk1vdXNlRG93bih0b29sRXZlbnQpO1xuICB9XG5cbiAgcGF0aEluaXQoKSB7XG4gICAgY29uc3QgeyBwYXRoUHJvcHMsIHBhdGhEYXRhLCBwYXBlciB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7IFBhdGggfSA9IHBhcGVyO1xuICAgIGNvbnN0IHBhdGggPSBuZXcgUGF0aChwYXRoUHJvcHMpO1xuICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgdGhpcy5zZXRQYXRoRGF0YShwYXRoRGF0YSk7XG4gIH1cblxuICBzZXRQYXRoRGF0YShwYXRoRGF0YTogc3RyaW5nKSB7XG4gICAgY29uc3QgeyBwYXRoIH0gPSB0aGlzO1xuICAgIHRoaXMucmVtb3ZlQm91bmRzKCk7XG4gICAgcGF0aC5wYXRoRGF0YSA9IHBhdGhEYXRhO1xuICAgIHBhdGguc2VnbWVudHMuZm9yRWFjaChzZWdtZW50ID0+IHRoaXMuY3JlYXRlQm91bmRzKHNlZ21lbnQpKTtcbiAgfVxuXG4gIG9uU2VnbWVudEFkZCh0b29sRXZlbnQ6IFRvb2xFdmVudCkge1xuICAgIGNvbnN0IHsgcGF0aCB9ID0gdGhpcztcbiAgICBwYXRoLmFkZCh0b29sRXZlbnQucG9pbnQpO1xuICAgIGNvbnN0IHNlZ21lbnQgPSBwYXRoLmxhc3RTZWdtZW50O1xuICAgIHRoaXMuY3JlYXRlQm91bmRzKHNlZ21lbnQpO1xuICAgIHRoaXMucHJvcHMub25TZWdtZW50QWRkKHNlZ21lbnQsIHBhdGgpO1xuICB9XG5cbiAgb25QYXRoQWRkKCkge1xuICAgIGNvbnN0IHsgc2VsZWN0ZWRTZWdtZW50LCBwYXRoLCBwb2ludHMgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBvblNlZ21lbnRSZW1vdmUsIG9uUGF0aEFkZCB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7IGluZGV4IH0gPSBzZWxlY3RlZFNlZ21lbnQ7XG4gICAgY29uc3Qgc2VnbWVudHMgPSBwYXRoLnJlbW92ZVNlZ21lbnRzKDAsIGluZGV4KTtcbiAgICBpZiAoc2VnbWVudHMubGVuZ3RoKSB7XG4gICAgICBvblNlZ21lbnRSZW1vdmUoc2VnbWVudHMsIHBhdGgpO1xuICAgIH1cbiAgICBwYXRoLmNsb3NlZCA9IHRydWU7XG4gICAgcGF0aC5zZWxlY3RlZCA9IGZhbHNlO1xuICAgIG9uUGF0aEFkZChwYXRoKTtcbiAgICB0aGlzLnBhdGggPSBudWxsO1xuICAgIHRoaXMuc2VsZWN0ZWRTZWdtZW50ID0gbnVsbDtcbiAgICBpZiAocG9pbnRzKSB7XG4gICAgICBwb2ludHMucmVtb3ZlKCk7XG4gICAgfVxuICB9XG5cbiAgY3JlYXRlQm91bmRzKHNlZ21lbnQ6IFNlZ21lbnQpIHtcbiAgICBjb25zdCB7IHBhcGVyIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHsgUGF0aCwgR3JvdXAsIHByb2plY3QgfSA9IHBhcGVyO1xuICAgIGNvbnN0IHsgcGF0aCwgcG9pbnRzIH0gPSB0aGlzO1xuICAgIGlmICghcG9pbnRzKSB7XG4gICAgICB0aGlzLnBvaW50cyA9IG5ldyBHcm91cCgpO1xuICAgICAgcHJvamVjdC5sYXllcnMuJCRtZXRhZGF0YS5hZGRDaGlsZCh0aGlzLnBvaW50cyk7XG4gICAgfVxuICAgIGNvbnN0IGJvdW5kcyA9IG5ldyBQYXRoLkNpcmNsZSh7XG4gICAgICBjZW50ZXI6IHNlZ21lbnQucG9pbnQsXG4gICAgICByYWRpdXM6IDcsXG4gICAgICBmaWxsQ29sb3I6ICd3aGl0ZScsXG4gICAgICBvcGFjaXR5OiAwLFxuICAgIH0pO1xuICAgIGJvdW5kcy5vbignbW91c2Vkb3duJywgKCkgPT4ge1xuICAgICAgaWYgKCFwYXRoLmNsb3NlZFxuICAgICAgICAgICYmICFwYXRoLmxhc3RTZWdtZW50LnBvaW50LmVxdWFscyhib3VuZHMucG9zaXRpb24pXG4gICAgICAgICAgJiYgcGF0aC5jb250YWlucyhib3VuZHMucG9zaXRpb24pKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRTZWdtZW50ID0gc2VnbWVudDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnBvaW50cy5hZGRDaGlsZChib3VuZHMpO1xuICB9XG5cbiAgcmVtb3ZlQm91bmRzKCkge1xuICAgIGlmICh0aGlzLnBvaW50cykge1xuICAgICAgdGhpcy5wb2ludHMucmVtb3ZlKCk7XG4gICAgICB0aGlzLnBvaW50cyA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgcG9pbnRzOiBQb2ludHM7XG5cbiAgc2VsZWN0ZWRTZWdtZW50OiBTZWdtZW50O1xuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBwYXRoUHJvcHMsIG9uTW91c2VEb3duLCBvblBhdGhBZGQsIG9uU2VnbWVudEFkZCwgb25TZWdtZW50UmVtb3ZlLCBwYXBlciwgaW5uZXJSZWYsIC4uLnJlc3RcbiAgICB9ID0gdGhpcy5wcm9wcztcbiAgICByZXR1cm4gKFxuICAgICAgPFRvb2xcbiAgICAgICAgcmVmPXtpbm5lclJlZn1cbiAgICAgICAgb25Nb3VzZURvd249e3RoaXMub25Nb3VzZURvd259XG4gICAgICAgIHsuLi5yZXN0fVxuICAgICAgLz5cbiAgICApO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFJlYWN0XG4gIC5mb3J3YXJkUmVmPFByb3BzLCBUb29sVHlwZT4oKHByb3BzLCByZWYpID0+IDxQb2x5Z29uVG9vbCBpbm5lclJlZj17cmVmfSB7Li4ucHJvcHN9IC8+KTtcbiIsIi8vIEBmbG93XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgKiBhcyBSZWFjdFBhcGVySlMgZnJvbSAnQHBzeWNob2JvbHQvcmVhY3QtcGFwZXJqcyc7XG5pbXBvcnQgdHlwZW9mIHsgUG9pbnQsIFRvb2xFdmVudCwgVG9vbCBhcyBUb29sVHlwZSB9IGZyb20gJ3BhcGVyJztcblxuaW1wb3J0IFBhdGhUb29sIGZyb20gJy4uL3NoYXJlZC9QYXRoVG9vbCc7XG5cbmNvbnN0IHsgVG9vbCwgUGFwZXJTY29wZSB9ID0gUmVhY3RQYXBlckpTO1xuXG50eXBlIFByb3BzID0ge1xuICBwYXRoUHJvcHM6IHtcbiAgICBmaWxsQ29sb3I6IHN0cmluZyxcbiAgfSxcbiAgaW5uZXJSZWY6IFJlYWN0LlJlZjxUb29sVHlwZT5cbn07XG5cbmNvbnN0IE1PVVNFX0xFRlRfQ09ERSA9IDA7XG5cbi8vICRGbG93Rml4TWVcbkBQYXBlclNjb3BlXG5jbGFzcyBSZWN0YW5nbGVUb29sIGV4dGVuZHMgUGF0aFRvb2w8UHJvcHM+IHtcbiAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICAuLi5QYXRoVG9vbC5kZWZhdWx0UHJvcHMsXG4gICAgcGF0aFByb3BzOiB7XG4gICAgICBmaWxsQ29sb3I6ICd3aGl0ZScsXG4gICAgICBzdHJva2VDb2xvcjogJ2JsYWNrJyxcbiAgICB9LFxuICB9XG5cbiAgb25Nb3VzZURvd24gPSAodG9vbEV2ZW50OiBUb29sRXZlbnQpID0+IHtcbiAgICBjb25zdCB7IHBhdGhQcm9wcywgb25Nb3VzZURvd24sIG9uUGF0aEluaXQsIHBhcGVyIH0gPSB0aGlzLnByb3BzO1xuICAgIGlmICh0b29sRXZlbnQuZXZlbnQuYnV0dG9uID09PSBNT1VTRV9MRUZUX0NPREUpIHtcbiAgICAgIGNvbnN0IHsgUGF0aCwgQ29sb3IgfSA9IHBhcGVyO1xuICAgICAgY29uc3Qgc3RhcnQgPSB0b29sRXZlbnQucG9pbnQ7XG4gICAgICBjb25zdCBwYXRoID0gbmV3IFBhdGguUmVjdGFuZ2xlKHtcbiAgICAgICAgcG9pbnQ6IHN0YXJ0LFxuICAgICAgICBzaXplOiBbMSwgMV0sXG4gICAgICAgIGZpbGxDb2xvcjogcGF0aFByb3BzLnNlbGVjdGVkRmlsbENvbG9yIHx8IG5ldyBDb2xvcigwLjksIDAuOSwgMSwgMC43NSksXG4gICAgICAgIHNlbGVjdGVkOiB0cnVlLFxuICAgICAgfSk7XG4gICAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgICAgb25QYXRoSW5pdChwYXRoKTtcbiAgICB9XG4gICAgb25Nb3VzZURvd24odG9vbEV2ZW50KTtcbiAgfVxuXG4gIG9uTW91c2VEcmFnID0gKHRvb2xFdmVudDogVG9vbEV2ZW50KSA9PiB7XG4gICAgY29uc3QgeyBvbk1vdXNlRHJhZyB9ID0gdGhpcy5wcm9wcztcbiAgICBpZiAodG9vbEV2ZW50LmV2ZW50LmJ1dHRvbnMgPT09IDEpIHtcbiAgICAgIGNvbnN0IHsgcGF0aCwgc3RhcnQgfSA9IHRoaXM7XG4gICAgICBjb25zdCB7IGJvdW5kcyB9ID0gcGF0aDtcbiAgICAgIGNvbnN0IG9mZnNldCA9IHRvb2xFdmVudC5wb2ludC5zdWJ0cmFjdChzdGFydCk7XG4gICAgICBjb25zdCB3aWR0aCA9IE1hdGguYWJzKG9mZnNldC54KTtcbiAgICAgIGNvbnN0IGhlaWdodCA9IE1hdGguYWJzKG9mZnNldC55KTtcbiAgICAgIGlmIChvZmZzZXQueCA8IDApIHtcbiAgICAgICAgYm91bmRzLmxlZnQgPSB0b29sRXZlbnQucG9pbnQueDtcbiAgICAgICAgYm91bmRzLnJpZ2h0ID0gc3RhcnQueDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJvdW5kcy5sZWZ0ID0gc3RhcnQueDtcbiAgICAgIH1cbiAgICAgIGlmIChvZmZzZXQueSA+IDApIHtcbiAgICAgICAgYm91bmRzLnRvcCA9IHN0YXJ0Lnk7XG4gICAgICAgIGJvdW5kcy5ib3R0b20gPSB0b29sRXZlbnQucG9pbnQueTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJvdW5kcy50b3AgPSB0b29sRXZlbnQucG9pbnQueTtcbiAgICAgIH1cbiAgICAgIGlmICh3aWR0aCA+IDApIHtcbiAgICAgICAgYm91bmRzLndpZHRoID0gd2lkdGg7XG4gICAgICB9XG4gICAgICBpZiAoaGVpZ2h0ID4gMCkge1xuICAgICAgICBib3VuZHMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgfVxuICAgIH1cbiAgICBvbk1vdXNlRHJhZyh0b29sRXZlbnQpO1xuICB9XG5cbiAgb25Nb3VzZVVwID0gKGV2ZW50OiBUb29sRXZlbnQpID0+IHtcbiAgICBjb25zdCB7IHBhdGggfSA9IHRoaXM7XG4gICAgY29uc3QgeyBwYXRoUHJvcHMsIG9uTW91c2VVcCwgb25QYXRoQWRkIH0gPSB0aGlzLnByb3BzO1xuICAgIGlmIChwYXRoKSB7XG4gICAgICBPYmplY3QuYXNzaWduKHBhdGgsIHtcbiAgICAgICAgc2VsZWN0ZWQ6IGZhbHNlLFxuICAgICAgICAuLi5wYXRoUHJvcHMsXG4gICAgICB9KTtcbiAgICAgIG9uUGF0aEFkZChwYXRoKTtcbiAgICAgIHRoaXMucGF0aCA9IG51bGw7XG4gICAgICB0aGlzLnN0YXJ0ID0gbnVsbDtcbiAgICB9XG4gICAgb25Nb3VzZVVwKGV2ZW50KTtcbiAgfVxuXG4gIHN0YXJ0OiBQb2ludDtcblxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBpbm5lclJlZiwgLi4ucmVzdCB9ID0gdGhpcy5wcm9wcztcbiAgICByZXR1cm4gKFxuICAgICAgPFRvb2xcbiAgICAgICAgey4uLnJlc3R9XG4gICAgICAgIHJlZj17aW5uZXJSZWZ9XG4gICAgICAgIG9uTW91c2VEb3duPXt0aGlzLm9uTW91c2VEb3dufVxuICAgICAgICBvbk1vdXNlRHJhZz17dGhpcy5vbk1vdXNlRHJhZ31cbiAgICAgICAgb25Nb3VzZVVwPXt0aGlzLm9uTW91c2VVcH1cbiAgICAgIC8+XG4gICAgKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBSZWFjdFxuICAuZm9yd2FyZFJlZjxQcm9wcywgVG9vbFR5cGU+KChwcm9wcywgcmVmKSA9PiA8UmVjdGFuZ2xlVG9vbCBpbm5lclJlZj17cmVmfSB7Li4ucHJvcHN9IC8+KTtcbiIsIi8vIEBmbG93XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgKiBhcyBSZWFjdFBhcGVySlMgZnJvbSAnQHBzeWNob2JvbHQvcmVhY3QtcGFwZXJqcyc7XG5pbXBvcnQgdHlwZW9mIHsgVG9vbEV2ZW50LCBUb29sIGFzIFRvb2xUeXBlIH0gZnJvbSAncGFwZXInO1xuXG5pbXBvcnQgUGF0aFRvb2wgZnJvbSAnLi4vc2hhcmVkL1BhdGhUb29sJztcblxuY29uc3QgeyBUb29sLCBQYXBlclNjb3BlIH0gPSBSZWFjdFBhcGVySlM7XG5cbnR5cGUgUHJvcHMgPSB7XG4gIHBhdGhQcm9wczoge1xuICAgIGZpbGxDb2xvcjogc3RyaW5nLFxuICAgIHN0cm9rZUNvbG9yOiBzdHJpbmcsXG4gIH0sXG4gIGlubmVyUmVmOiBSZWFjdC5SZWY8VG9vbFR5cGU+XG59O1xuXG5jb25zdCBNT1VTRV9MRUZUX0NPREUgPSAwO1xuXG4vLyAkRmxvd0ZpeE1lXG5AUGFwZXJTY29wZVxuY2xhc3MgQ2lyY2xlVG9vbCBleHRlbmRzIFBhdGhUb29sPFByb3BzPiB7XG4gIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgLi4uUGF0aFRvb2wuZGVmYXVsdFByb3BzLFxuICAgIHBhdGhQcm9wczoge1xuICAgICAgZmlsbENvbG9yOiAnd2hpdGUnLFxuICAgICAgc3Ryb2tlQ29sb3I6ICdibGFjaycsXG4gICAgfSxcbiAgfVxuXG4gIG9uTW91c2VEb3duID0gKHRvb2xFdmVudDogVG9vbEV2ZW50KSA9PiB7XG4gICAgY29uc3QgeyBwYXRoUHJvcHMsIG9uTW91c2VEb3duLCBvblBhdGhJbml0LCBwYXBlciB9ID0gdGhpcy5wcm9wcztcbiAgICBpZiAodG9vbEV2ZW50LmV2ZW50LmJ1dHRvbiA9PT0gTU9VU0VfTEVGVF9DT0RFKSB7XG4gICAgICBjb25zdCB7IFBhdGgsIENvbG9yIH0gPSBwYXBlcjtcbiAgICAgIGNvbnN0IHBhdGggPSBuZXcgUGF0aC5DaXJjbGUoe1xuICAgICAgICBjZW50ZXI6IHRvb2xFdmVudC5wb2ludCxcbiAgICAgICAgcmFkaXVzOiAxLFxuICAgICAgICBmaWxsQ29sb3I6IHBhdGhQcm9wcy5zZWxlY3RlZEZpbGxDb2xvciB8fCBuZXcgQ29sb3IoMC45LCAwLjksIDEsIDAuNzUpLFxuICAgICAgICBzZWxlY3RlZDogdHJ1ZSxcbiAgICAgIH0pO1xuICAgICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICAgIG9uUGF0aEluaXQocGF0aCk7XG4gICAgfVxuICAgIG9uTW91c2VEb3duKHRvb2xFdmVudCk7XG4gIH1cblxuICBvbk1vdXNlRHJhZyA9ICh0b29sRXZlbnQ6IFRvb2xFdmVudCkgPT4ge1xuICAgIGNvbnN0IHsgb25Nb3VzZURyYWcgfSA9IHRoaXMucHJvcHM7XG4gICAgaWYgKHRvb2xFdmVudC5ldmVudC5idXR0b25zID09PSAxKSB7XG4gICAgICBjb25zdCB7IHBhdGggfSA9IHRoaXM7XG4gICAgICBjb25zdCBzY2FsZSA9IE1hdGguYWJzKHRvb2xFdmVudC5wb2ludC5nZXREaXN0YW5jZShwYXRoLnBvc2l0aW9uKSAvIChwYXRoLmJvdW5kcy53aWR0aCAvIDIpKTtcbiAgICAgIGlmIChzY2FsZSA+IDAuMSkge1xuICAgICAgICBwYXRoLnNjYWxlKHNjYWxlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgb25Nb3VzZURyYWcodG9vbEV2ZW50KTtcbiAgfVxuXG4gIG9uTW91c2VVcCA9IChldmVudDogVG9vbEV2ZW50KSA9PiB7XG4gICAgY29uc3QgeyBwYXRoIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgcGF0aFByb3BzLCBvbk1vdXNlVXAsIG9uUGF0aEFkZCB9ID0gdGhpcy5wcm9wcztcbiAgICBpZiAocGF0aCkge1xuICAgICAgT2JqZWN0LmFzc2lnbihwYXRoLCB7XG4gICAgICAgIHNlbGVjdGVkOiBmYWxzZSxcbiAgICAgICAgLi4ucGF0aFByb3BzLFxuICAgICAgfSk7XG4gICAgICBvblBhdGhBZGQocGF0aCk7XG4gICAgICB0aGlzLnBhdGggPSBudWxsO1xuICAgIH1cbiAgICBvbk1vdXNlVXAoZXZlbnQpO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgaW5uZXJSZWYsIC4uLnJlc3QgfSA9IHRoaXMucHJvcHM7XG4gICAgcmV0dXJuIChcbiAgICAgIDxUb29sXG4gICAgICAgIHJlZj17aW5uZXJSZWZ9XG4gICAgICAgIHsuLi5yZXN0fVxuICAgICAgICBvbk1vdXNlRG93bj17dGhpcy5vbk1vdXNlRG93bn1cbiAgICAgICAgb25Nb3VzZURyYWc9e3RoaXMub25Nb3VzZURyYWd9XG4gICAgICAgIG9uTW91c2VVcD17dGhpcy5vbk1vdXNlVXB9XG4gICAgICAvPlxuICAgICk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgUmVhY3RcbiAgLmZvcndhcmRSZWY8UHJvcHMsIFRvb2xUeXBlPigocHJvcHMsIHJlZikgPT4gPENpcmNsZVRvb2wgaW5uZXJSZWY9e3JlZn0gey4uLnByb3BzfSAvPik7XG4iLCIvLyBAZmxvd1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0ICogYXMgUmVhY3RQYXBlckpTIGZyb20gJ0Bwc3ljaG9ib2x0L3JlYWN0LXBhcGVyanMnO1xuaW1wb3J0IHR5cGVvZiB7IFRvb2xFdmVudCwgVG9vbCBhcyBUb29sVHlwZSB9IGZyb20gJ3BhcGVyJztcblxuaW1wb3J0IFBhdGhUb29sIGZyb20gJy4uL3NoYXJlZC9QYXRoVG9vbCc7XG5cbmNvbnN0IHsgVG9vbCwgUGFwZXJTY29wZSB9ID0gUmVhY3RQYXBlckpTO1xuXG50eXBlIFByb3BzID0ge1xuICBwYXRoUHJvcHM6IHtcbiAgICBzdHJva2VDb2xvcjogc3RyaW5nLFxuICB9LFxuICBwYXRoRGF0YTogc3RyaW5nLFxuICBpbm5lclJlZjogUmVhY3QuUmVmPFRvb2xUeXBlPlxufTtcblxuY29uc3QgTU9VU0VfTEVGVF9DT0RFID0gMDtcblxuLy8gJEZsb3dGaXhNZVxuQFBhcGVyU2NvcGVcbmNsYXNzIFNlZ21lbnRQYXRoVG9vbCBleHRlbmRzIFBhdGhUb29sPFByb3BzPiB7XG4gIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgLi4uUGF0aFRvb2wuZGVmYXVsdFByb3BzLFxuICAgIHBhdGhQcm9wczoge1xuICAgICAgc3Ryb2tlQ29sb3I6ICdibGFjaycsXG4gICAgICBzZWxlY3RlZDogdHJ1ZSxcbiAgICB9LFxuICB9O1xuXG4gIG9uS2V5VXAgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBwYXRoLCBvblBhdGhBZGQgfSA9IHRoaXM7XG4gICAgaWYgKHBhdGgpIHtcbiAgICAgIGlmIChwYXRoLnNlZ21lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgb25QYXRoQWRkKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXRoLnJlbW92ZSgpO1xuICAgICAgICB0aGlzLnBhdGggPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIG9uTW91c2VEb3duID0gKHRvb2xFdmVudDogVG9vbEV2ZW50KSA9PiB7XG4gICAgY29uc3QgeyBwYXRoIH0gPSB0aGlzO1xuICAgIGlmICh0b29sRXZlbnQuZXZlbnQuYnV0dG9uID09PSBNT1VTRV9MRUZUX0NPREUgJiYgdG9vbEV2ZW50Lm1vZGlmaWVycy5zaGlmdCkge1xuICAgICAgaWYgKCFwYXRoKSB7XG4gICAgICAgIHRoaXMucGF0aEluaXQoKTtcbiAgICAgICAgdGhpcy5wcm9wcy5vblBhdGhJbml0KHBhdGgpO1xuICAgICAgfVxuICAgICAgdGhpcy5vblNlZ21lbnRBZGQodG9vbEV2ZW50KTtcbiAgICB9XG4gICAgdGhpcy5wcm9wcy5vbk1vdXNlRG93bih0b29sRXZlbnQpO1xuICB9XG5cbiAgcGF0aEluaXQoKSB7XG4gICAgY29uc3QgeyBwYXRoUHJvcHMsIHBhdGhEYXRhLCBwYXBlciB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7IFBhdGggfSA9IHBhcGVyO1xuICAgIGNvbnN0IHBhdGggPSBuZXcgUGF0aChwYXRoUHJvcHMpO1xuICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgdGhpcy5zZXRQYXRoRGF0YShwYXRoRGF0YSk7XG4gIH1cblxuICBzZXRQYXRoRGF0YShwYXRoRGF0YTogc3RyaW5nKSB7XG4gICAgdGhpcy5wYXRoLnBhdGhEYXRhID0gcGF0aERhdGE7XG4gIH1cblxuICBvblNlZ21lbnRBZGQodG9vbEV2ZW50OiBUb29sRXZlbnQpIHtcbiAgICBjb25zdCB7IHBhdGggfSA9IHRoaXM7XG4gICAgcGF0aC5hZGQodG9vbEV2ZW50LnBvaW50KTtcbiAgICB0aGlzLnByb3BzLm9uU2VnbWVudEFkZChwYXRoLmxhc3RTZWdtZW50LCBwYXRoKTtcbiAgfVxuXG4gIG9uUGF0aEFkZCA9ICgpID0+IHtcbiAgICBjb25zdCB7IHBhdGggfSA9IHRoaXM7XG4gICAgY29uc3QgeyBvblBhdGhBZGQgfSA9IHRoaXMucHJvcHM7XG4gICAgcGF0aC5zZWxlY3RlZCA9IGZhbHNlO1xuICAgIG9uUGF0aEFkZChwYXRoKTtcbiAgICB0aGlzLnBhdGggPSBudWxsO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHBhdGhQcm9wcyxcbiAgICAgIG9uS2V5VXAsXG4gICAgICBvbk1vdXNlRG93bixcbiAgICAgIG9uUGF0aEFkZCxcbiAgICAgIG9uU2VnbWVudEFkZCxcbiAgICAgIG9uU2VnbWVudFJlbW92ZSxcbiAgICAgIHBhcGVyLFxuICAgICAgaW5uZXJSZWYsXG4gICAgICAuLi5yZXN0XG4gICAgfSA9IHRoaXMucHJvcHM7XG4gICAgcmV0dXJuIChcbiAgICAgIDxUb29sXG4gICAgICAgIHJlZj17aW5uZXJSZWZ9XG4gICAgICAgIG9uS2V5VXA9e3RoaXMub25LZXlVcH1cbiAgICAgICAgb25Nb3VzZURvd249e3RoaXMub25Nb3VzZURvd259XG4gICAgICAgIHsuLi5yZXN0fVxuICAgICAgLz5cbiAgICApO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFJlYWN0XG4gIC5mb3J3YXJkUmVmPFByb3BzLCBUb29sVHlwZT4oKHByb3BzLCByZWYpID0+IDxTZWdtZW50UGF0aFRvb2wgaW5uZXJSZWY9e3JlZn0gey4uLnByb3BzfSAvPik7XG4iLCIvLyBAZmxvd1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0ICogYXMgUmVhY3RQYXBlckpTIGZyb20gJ0Bwc3ljaG9ib2x0L3JlYWN0LXBhcGVyanMnO1xuaW1wb3J0IHR5cGUgeyBFdmVudEhhbmRsZXIgfSBmcm9tICdAcHN5Y2hvYm9sdC9yZWFjdC1wYXBlcmpzJztcbmltcG9ydCB0eXBlIHsgUGFwZXJTY29wZSBhcyBQYXBlclNjb3BlVHlwZSwgS2V5RXZlbnQsIE1vdXNlRXZlbnQgfSBmcm9tICdwYXBlcic7XG5cbmNvbnN0IHsgUGFwZXJTY29wZSwgZ2V0UHJvcHMgfSA9IFJlYWN0UGFwZXJKUztcblxudHlwZSBQcm9wcyA9IHtcbiAgb25QYW5FbmFibGVkPzogKCkgPT4gYW55LFxuICBvblBhbkRpc2FibGVkPzogKCkgPT4gYW55LFxuICBvblpvb20/OiAobGV2ZWw6IG51bWJlcikgPT4gYW55LFxuICB6b29tTGV2ZWw/OiBudW1iZXIsXG4gIGNlbnRlcjogT2JqZWN0IHwgbnVtYmVyW10sXG4gIHBhcGVyOiBQYXBlclNjb3BlVHlwZSxcbiAgbWVyZ2VQcm9wczogKHN0YXRlOiB7fSwgcHJvcHM/OiB7fSkgPT4ge30sXG4gIGNoaWxkcmVuOiBhbnksXG59O1xuXG50eXBlIFN0YXRlID0ge1xuICBkcmFnZ2FibGU6IGJvb2xlYW4sXG4gIGRyYWdTdGFydDogP09iamVjdCxcbn07XG5cbmZ1bmN0aW9uIGFkZChudW0xLCBudW0yKSB7XG4gIHJldHVybiAoKG51bTEgKiAxMCkgKyAobnVtMiAqIDEwKSkgLyAxMDtcbn1cblxuZnVuY3Rpb24gY2FsbEFsbEhhbmRsZXJzKGhhbmRsZXJzOiBFdmVudEhhbmRsZXJbXSA9IFtdKSB7XG4gIHJldHVybiBldmVudCA9PiBoYW5kbGVycy5mb3JFYWNoKGhhbmRsZXIgPT4gaGFuZGxlciAmJiBoYW5kbGVyKGV2ZW50KSk7XG59XG5cbi8vICRGbG93Rml4TWVcbmV4cG9ydCBkZWZhdWx0IEBQYXBlclNjb3BlIGNsYXNzIFBhbkFuZFNjcm9sbCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDxQcm9wcywgU3RhdGU+IHtcbiAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICB6b29tTGV2ZWw6IDEsXG4gICAgb25QYW5FbmFibGVkOiAoKSA9PiB7fSxcbiAgICBvblBhbkRpc2FibGVkOiAoKSA9PiB7fSxcbiAgICBvblpvb206ICgpID0+IHt9LFxuICB9O1xuXG4gIGNvbnN0cnVjdG9yKHByb3BzOiBQcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgZHJhZ2dhYmxlOiBmYWxzZSxcbiAgICAgIGRyYWdTdGFydDogbnVsbCxcbiAgICB9O1xuICB9XG5cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgY29uc3QgeyBwYXBlciwgem9vbUxldmVsLCBjZW50ZXIsIG1lcmdlUHJvcHMgfSA9IHRoaXMucHJvcHM7XG4gICAgbWVyZ2VQcm9wcygoc3RhdGUsIHByb3BzKSA9PiB7XG4gICAgICBjb25zdCB7IG9uV2hlZWwsIC4uLmNhbnZhc1Byb3BzIH0gPSBnZXRQcm9wcyhwYXBlciwgcHJvcHMuY2FudmFzUHJvcHMpO1xuICAgICAgY29uc3Qge1xuICAgICAgICBvbktleURvd24sIG9uS2V5VXAsIG9uTW91c2VEb3duLCBvbk1vdXNlRHJhZywgb25Nb3VzZVVwLCAuLi52aWV3UHJvcHNcbiAgICAgIH0gPSBnZXRQcm9wcyhwYXBlciwgcHJvcHMudmlld1Byb3BzKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNhbnZhc1Byb3BzOiB7XG4gICAgICAgICAgLi4uY2FudmFzUHJvcHMsXG4gICAgICAgICAgb25XaGVlbDogY2FsbEFsbEhhbmRsZXJzKFtvbldoZWVsLCB0aGlzLm9uV2hlZWxdKSxcbiAgICAgICAgICAnZHJhZy1zdGF0ZSc6ICdkaXNhYmxlZCcsXG4gICAgICAgIH0sXG4gICAgICAgIHZpZXdQcm9wczoge1xuICAgICAgICAgIC4uLnZpZXdQcm9wcyxcbiAgICAgICAgICBvbktleURvd246IGNhbGxBbGxIYW5kbGVycyhbb25LZXlEb3duLCB0aGlzLm9uS2V5RG93bl0pLFxuICAgICAgICAgIG9uS2V5VXA6IGNhbGxBbGxIYW5kbGVycyhbb25LZXlVcCwgdGhpcy5vbktleVVwXSksXG4gICAgICAgICAgb25Nb3VzZURvd246IGNhbGxBbGxIYW5kbGVycyhbb25Nb3VzZURvd24sIHRoaXMub25Nb3VzZURvd25dKSxcbiAgICAgICAgICBvbk1vdXNlRHJhZzogY2FsbEFsbEhhbmRsZXJzKFtvbk1vdXNlRHJhZywgdGhpcy5vbk1vdXNlRHJhZ10pLFxuICAgICAgICAgIG9uTW91c2VVcDogY2FsbEFsbEhhbmRsZXJzKFtvbk1vdXNlVXAsIHRoaXMub25Nb3VzZVVwXSksXG4gICAgICAgICAgem9vbTogem9vbUxldmVsLFxuICAgICAgICAgIGNlbnRlcixcbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICBvbldoZWVsID0gKHsgZGVsdGFZIH06IFN5bnRoZXRpY1doZWVsRXZlbnQ8SFRNTENhbnZhc0VsZW1lbnQ+KSA9PiB7XG4gICAgY29uc3QgeyBvblpvb20sIG1lcmdlUHJvcHMgfSA9IHRoaXMucHJvcHM7XG4gICAgbWVyZ2VQcm9wcygoc3RhdGUsIHByb3BzKSA9PiB7XG4gICAgICBsZXQgeyB6b29tIH0gPSBzdGF0ZS52aWV3UHJvcHM7XG4gICAgICBpZiAoZGVsdGFZIDwgMCkge1xuICAgICAgICB6b29tID0gYWRkKHpvb20sIDAuMSk7XG4gICAgICAgIGlmIChvblpvb20pIG9uWm9vbSh6b29tKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB2aWV3UHJvcHM6IHtcbiAgICAgICAgICAgIC4uLnByb3BzLnZpZXdQcm9wcyxcbiAgICAgICAgICAgIC4uLnN0YXRlLnZpZXdQcm9wcyxcbiAgICAgICAgICAgIHpvb20sXG4gICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmIChkZWx0YVkgPiAwICYmIHpvb20gPiAwLjEpIHtcbiAgICAgICAgem9vbSA9IGFkZCh6b29tLCAtMC4xKTtcbiAgICAgICAgaWYgKG9uWm9vbSkgb25ab29tKHpvb20pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHZpZXdQcm9wczoge1xuICAgICAgICAgICAgLi4ucHJvcHMudmlld1Byb3BzLFxuICAgICAgICAgICAgLi4uc3RhdGUudmlld1Byb3BzLFxuICAgICAgICAgICAgem9vbSxcbiAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSk7XG4gIH1cblxuICBvbktleURvd24gPSAoeyBrZXkgfTogS2V5RXZlbnQpID0+IHtcbiAgICBjb25zdCB7IGRyYWdnYWJsZSB9ID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAoa2V5ID09PSAnc3BhY2UnICYmICFkcmFnZ2FibGUpIHtcbiAgICAgIGNvbnN0IHsgb25QYW5FbmFibGVkLCBtZXJnZVByb3BzIH0gPSB0aGlzLnByb3BzO1xuICAgICAgbWVyZ2VQcm9wcygoc3RhdGUsIHByb3BzKSA9PiAoe1xuICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgY2FudmFzUHJvcHM6IHtcbiAgICAgICAgICAuLi5wcm9wcy5jYW52YXNQcm9wcyxcbiAgICAgICAgICAuLi5zdGF0ZS5jYW52YXNQcm9wcyxcbiAgICAgICAgICAnZHJhZy1zdGF0ZSc6ICdlbmFibGVkJyxcbiAgICAgICAgfSxcbiAgICAgIH0pKTtcbiAgICAgIHRoaXMuc2V0U3RhdGUoeyBkcmFnZ2FibGU6IHRydWUgfSk7XG4gICAgICBpZiAob25QYW5FbmFibGVkKSBvblBhbkVuYWJsZWQoKTtcbiAgICB9XG4gIH1cblxuICBvbktleVVwID0gKHsga2V5IH06IEtleUV2ZW50KSA9PiB7XG4gICAgaWYgKGtleSA9PT0gJ3NwYWNlJykge1xuICAgICAgY29uc3QgeyBvblBhbkRpc2FibGVkLCBtZXJnZVByb3BzIH0gPSB0aGlzLnByb3BzO1xuICAgICAgbWVyZ2VQcm9wcygoc3RhdGUsIHByb3BzKSA9PiAoe1xuICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgY2FudmFzUHJvcHM6IHtcbiAgICAgICAgICAuLi5wcm9wcy5jYW52YXNQcm9wcyxcbiAgICAgICAgICAuLi5zdGF0ZS5jYW52YXNQcm9wcyxcbiAgICAgICAgICAnZHJhZy1zdGF0ZSc6ICdkaXNhYmxlZCcsXG4gICAgICAgIH0sXG4gICAgICB9KSk7XG4gICAgICB0aGlzLnNldFN0YXRlKHsgZHJhZ2dhYmxlOiBmYWxzZSB9KTtcbiAgICAgIGlmIChvblBhbkRpc2FibGVkKSBvblBhbkRpc2FibGVkKCk7XG4gICAgfVxuICB9XG5cbiAgb25Nb3VzZURvd24gPSAoeyBwb2ludCB9OiBNb3VzZUV2ZW50KSA9PiB7XG4gICAgY29uc3QgeyBkcmFnZ2FibGUsIGRyYWdTdGFydCB9ID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAoZHJhZ2dhYmxlICYmICFkcmFnU3RhcnQpIHtcbiAgICAgIGNvbnN0IHsgbWVyZ2VQcm9wcyB9ID0gdGhpcy5wcm9wcztcbiAgICAgIG1lcmdlUHJvcHMoKHN0YXRlLCBwcm9wcykgPT4gKHtcbiAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgIGNhbnZhc1Byb3BzOiB7XG4gICAgICAgICAgLi4ucHJvcHMuY2FudmFzUHJvcHMsXG4gICAgICAgICAgLi4uc3RhdGUuY2FudmFzUHJvcHMsXG4gICAgICAgICAgJ2RyYWctc3RhdGUnOiAnZHJhZ2dpbmcnLFxuICAgICAgICB9LFxuICAgICAgfSkpO1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7IGRyYWdTdGFydDogcG9pbnQgfSk7XG4gICAgfVxuICB9XG5cbiAgb25Nb3VzZVVwID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgZHJhZ1N0YXJ0LCBkcmFnZ2FibGUgfSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKGRyYWdTdGFydCkge1xuICAgICAgaWYgKGRyYWdnYWJsZSkge1xuICAgICAgICBjb25zdCB7IG1lcmdlUHJvcHMgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIG1lcmdlUHJvcHMoKHN0YXRlLCBwcm9wcykgPT4gKHtcbiAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICBjYW52YXNQcm9wczoge1xuICAgICAgICAgICAgLi4ucHJvcHMuY2FudmFzUHJvcHMsXG4gICAgICAgICAgICAuLi5zdGF0ZS5jYW52YXNQcm9wcyxcbiAgICAgICAgICAgICdkcmFnLXN0YXRlJzogJ2VuYWJsZWQnLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0U3RhdGUoeyBkcmFnU3RhcnQ6IG51bGwgfSk7XG4gICAgfVxuICB9XG5cbiAgb25Nb3VzZURyYWcgPSAoeyBwb2ludCB9OiBNb3VzZUV2ZW50KSA9PiB7XG4gICAgY29uc3QgeyBtZXJnZVByb3BzLCBwYXBlciB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7IGRyYWdnYWJsZSwgZHJhZ1N0YXJ0IH0gPSB0aGlzLnN0YXRlO1xuICAgIG1lcmdlUHJvcHMoKHN0YXRlLCBwcm9wcykgPT4ge1xuICAgICAgaWYgKGRyYWdTdGFydCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHZpZXdQcm9wczoge1xuICAgICAgICAgICAgLi4ucHJvcHMudmlld1Byb3BzLFxuICAgICAgICAgICAgLi4uc3RhdGUudmlld1Byb3BzLFxuICAgICAgICAgICAgY2VudGVyOlxuICAgICAgICAgICAgICBwYXBlci52aWV3LmNlbnRlclxuICAgICAgICAgICAgICAgIC5hZGQocG9pbnQuc3VidHJhY3QoZHJhZ1N0YXJ0KVxuICAgICAgICAgICAgICAgICAgLm11bHRpcGx5KDAuNSkpLFxuICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9KTtcbiAgICBpZiAoZHJhZ2dhYmxlKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHsgZHJhZ1N0YXJ0OiBwb2ludCB9KTtcbiAgICB9XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBjaGlsZHJlbiB9ID0gdGhpcy5wcm9wcztcbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH1cbn1cbiIsIi8vIEBmbG93XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgKiBhcyBSZWFjdFBhcGVySlMgZnJvbSAnQHBzeWNob2JvbHQvcmVhY3QtcGFwZXJqcyc7XG5pbXBvcnQgdHlwZW9mIHsgUG9pbnQsIFRvb2xFdmVudCwgVG9vbCBhcyBUb29sVHlwZSB9IGZyb20gJ3BhcGVyJztcblxuaW1wb3J0IFBhdGhUb29sIGZyb20gJy4uL3NoYXJlZC9QYXRoVG9vbCc7XG5cbmNvbnN0IHsgVG9vbCwgUGFwZXJTY29wZSB9ID0gUmVhY3RQYXBlckpTO1xuXG50eXBlIFByb3BzID0ge1xuICBwYXRoUHJvcHM6IHtcbiAgICBmaWxsQ29sb3I6IHN0cmluZyxcbiAgfSxcbiAgaW5uZXJSZWY6IFJlYWN0LlJlZjxUb29sVHlwZT5cbn07XG5cbmNvbnN0IE1PVVNFX0xFRlRfQ09ERSA9IDA7XG5cbi8vICRGbG93Rml4TWVcbkBQYXBlclNjb3BlXG5jbGFzcyBFbGxpcHNlVG9vbCBleHRlbmRzIFBhdGhUb29sPFByb3BzPiB7XG4gIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgLi4uUGF0aFRvb2wuZGVmYXVsdFByb3BzLFxuICAgIHBhdGhQcm9wczoge1xuICAgICAgZmlsbENvbG9yOiAnd2hpdGUnLFxuICAgICAgc3Ryb2tlQ29sb3I6ICdibGFjaycsXG4gICAgfSxcbiAgfVxuXG4gIG9uTW91c2VEb3duID0gKHRvb2xFdmVudDogVG9vbEV2ZW50KSA9PiB7XG4gICAgY29uc3QgeyBwYXRoUHJvcHMsIG9uTW91c2VEb3duLCBvblBhdGhJbml0LCBwYXBlciB9ID0gdGhpcy5wcm9wcztcbiAgICBpZiAodG9vbEV2ZW50LmV2ZW50LmJ1dHRvbiA9PT0gTU9VU0VfTEVGVF9DT0RFKSB7XG4gICAgICBjb25zdCB7IFBhdGgsIENvbG9yIH0gPSBwYXBlcjtcbiAgICAgIGNvbnN0IHN0YXJ0ID0gdG9vbEV2ZW50LnBvaW50O1xuICAgICAgY29uc3QgcGF0aCA9IG5ldyBQYXRoLkVsbGlwc2Uoe1xuICAgICAgICBwb2ludDogc3RhcnQsXG4gICAgICAgIHNpemU6IFsxLCAxXSxcbiAgICAgICAgZmlsbENvbG9yOiBwYXRoUHJvcHMuc2VsZWN0ZWRGaWxsQ29sb3IgfHwgbmV3IENvbG9yKDAuOSwgMC45LCAxLCAwLjc1KSxcbiAgICAgICAgc2VsZWN0ZWQ6IHRydWUsXG4gICAgICB9KTtcblxuICAgICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICAgIHRoaXMuc3RhcnQgPSBzdGFydDtcbiAgICAgIG9uUGF0aEluaXQodGhpcy5wYXRoKTtcbiAgICB9XG4gICAgb25Nb3VzZURvd24odG9vbEV2ZW50KTtcbiAgfVxuXG4gIG9uTW91c2VEcmFnID0gKHRvb2xFdmVudDogVG9vbEV2ZW50KSA9PiB7XG4gICAgY29uc3QgeyBvbk1vdXNlRHJhZyB9ID0gdGhpcy5wcm9wcztcbiAgICBpZiAodG9vbEV2ZW50LmV2ZW50LmJ1dHRvbnMgPT09IDEpIHtcbiAgICAgIGNvbnN0IHsgcGF0aCwgc3RhcnQgfSA9IHRoaXM7XG4gICAgICBjb25zdCB7IGJvdW5kcyB9ID0gcGF0aDtcbiAgICAgIGNvbnN0IG9mZnNldCA9IHRvb2xFdmVudC5wb2ludC5zdWJ0cmFjdChzdGFydCk7XG4gICAgICBjb25zdCB3aWR0aCA9IE1hdGguYWJzKG9mZnNldC54KTtcbiAgICAgIGNvbnN0IGhlaWdodCA9IE1hdGguYWJzKG9mZnNldC55KTtcbiAgICAgIGlmIChvZmZzZXQueCA8IDApIHtcbiAgICAgICAgYm91bmRzLmxlZnQgPSB0b29sRXZlbnQucG9pbnQueDtcbiAgICAgICAgYm91bmRzLnJpZ2h0ID0gc3RhcnQueDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJvdW5kcy5sZWZ0ID0gc3RhcnQueDtcbiAgICAgIH1cbiAgICAgIGlmIChvZmZzZXQueSA+IDApIHtcbiAgICAgICAgYm91bmRzLnRvcCA9IHN0YXJ0Lnk7XG4gICAgICAgIGJvdW5kcy5ib3R0b20gPSB0b29sRXZlbnQucG9pbnQueTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJvdW5kcy50b3AgPSB0b29sRXZlbnQucG9pbnQueTtcbiAgICAgIH1cbiAgICAgIGlmICh3aWR0aCA+IDApIHtcbiAgICAgICAgYm91bmRzLndpZHRoID0gd2lkdGg7XG4gICAgICB9XG4gICAgICBpZiAoaGVpZ2h0ID4gMCkge1xuICAgICAgICBib3VuZHMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgfVxuICAgIH1cbiAgICBvbk1vdXNlRHJhZyh0b29sRXZlbnQpO1xuICB9XG5cbiAgb25Nb3VzZVVwID0gKGV2ZW50OiBUb29sRXZlbnQpID0+IHtcbiAgICBjb25zdCB7IHBhdGggfSA9IHRoaXM7XG4gICAgY29uc3QgeyBwYXRoUHJvcHMsIG9uTW91c2VVcCwgb25QYXRoQWRkIH0gPSB0aGlzLnByb3BzO1xuICAgIGlmIChwYXRoKSB7XG4gICAgICBPYmplY3QuYXNzaWduKHBhdGgsIHtcbiAgICAgICAgc2VsZWN0ZWQ6IGZhbHNlLFxuICAgICAgICAuLi5wYXRoUHJvcHMsXG4gICAgICB9KTtcbiAgICAgIG9uUGF0aEFkZChwYXRoKTtcbiAgICAgIHRoaXMucGF0aCA9IG51bGw7XG4gICAgICB0aGlzLnN0YXJ0ID0gbnVsbDtcbiAgICB9XG4gICAgb25Nb3VzZVVwKGV2ZW50KTtcbiAgfVxuXG4gIHN0YXJ0OiBQb2ludDtcblxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBpbm5lclJlZiwgLi4ucmVzdCB9ID0gdGhpcy5wcm9wcztcbiAgICByZXR1cm4gKFxuICAgICAgPFRvb2xcbiAgICAgICAgey4uLnJlc3R9XG4gICAgICAgIHJlZj17aW5uZXJSZWZ9XG4gICAgICAgIG9uTW91c2VEb3duPXt0aGlzLm9uTW91c2VEb3dufVxuICAgICAgICBvbk1vdXNlRHJhZz17dGhpcy5vbk1vdXNlRHJhZ31cbiAgICAgICAgb25Nb3VzZVVwPXt0aGlzLm9uTW91c2VVcH1cbiAgICAgIC8+XG4gICAgKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBSZWFjdFxuICAuZm9yd2FyZFJlZjxQcm9wcywgVG9vbFR5cGU+KChwcm9wcywgcmVmKSA9PiA8RWxsaXBzZVRvb2wgaW5uZXJSZWY9e3JlZn0gey4uLnByb3BzfSAvPik7XG4iXSwibmFtZXMiOlsiUGF0aFRvb2wiLCJwYXRoIiwiUmVhY3QiLCJkZWZhdWx0UHJvcHMiLCJvbktleURvd24iLCJvbktleVVwIiwib25Nb3VzZURvd24iLCJvbk1vdXNlRHJhZyIsIm9uTW91c2VVcCIsIm9uUGF0aEluaXQiLCJvblBhdGhBZGQiLCJvblNlZ21lbnRBZGQiLCJvblNlZ21lbnRSZW1vdmUiLCJUb29sIiwiUmVhY3RQYXBlckpTIiwiUGFwZXJTY29wZSIsIk1PVVNFX0xFRlRfQ09ERSIsIkZyZWVmb3JtUGF0aFRvb2wiLCJ0b29sRXZlbnQiLCJwcm9wcyIsInBhdGhQcm9wcyIsInBhcGVyIiwiZXZlbnQiLCJidXR0b24iLCJQYXRoIiwiYnV0dG9ucyIsImFkZCIsInBvaW50IiwiaW5uZXJSZWYiLCJyZXN0IiwiUmVhY3QuY3JlYXRlRWxlbWVudCIsInN0cm9rZUNvbG9yIiwicmVmIiwiTGF5ZXIiLCJHcm91cCIsIkxpbmUiLCJHcmlkIiwid2lkdGgiLCJoZWlnaHQiLCJ0b3AiLCJsZWZ0IiwicmlnaHQiLCJib3R0b20iLCJjZWxsU2l6ZSIsInN0cm9rZVdpZHRoIiwieCIsIk1hdGgiLCJjZWlsIiwieSIsImNvbHMiLCJyb3dzIiwidmVydGljYWxMaW5lcyIsImhvcml6b250YWxMaW5lcyIsImkiLCJwb3NpdGlvbiIsInB1c2giLCJMaW5lVG9vbCIsInJlbW92ZVNlZ21lbnQiLCJhZGRTZWdtZW50Iiwic2VsZWN0ZWQiLCJQb2x5Z29uVG9vbCIsInBhdGhJbml0Iiwic2VsZWN0ZWRTZWdtZW50IiwicG9pbnRzIiwicGF0aERhdGEiLCJzZXRQYXRoRGF0YSIsIk9iamVjdCIsImFzc2lnbiIsInJlbW92ZUJvdW5kcyIsInNlZ21lbnRzIiwiZm9yRWFjaCIsInNlZ21lbnQiLCJjcmVhdGVCb3VuZHMiLCJsYXN0U2VnbWVudCIsImluZGV4IiwicmVtb3ZlU2VnbWVudHMiLCJsZW5ndGgiLCJjbG9zZWQiLCJyZW1vdmUiLCJwcm9qZWN0IiwibGF5ZXJzIiwiJCRtZXRhZGF0YSIsImFkZENoaWxkIiwiYm91bmRzIiwiQ2lyY2xlIiwiY2VudGVyIiwicmFkaXVzIiwiZmlsbENvbG9yIiwib3BhY2l0eSIsIm9uIiwiZXF1YWxzIiwiY29udGFpbnMiLCJSZWN0YW5nbGVUb29sIiwiQ29sb3IiLCJzdGFydCIsIlJlY3RhbmdsZSIsInNpemUiLCJzZWxlY3RlZEZpbGxDb2xvciIsIm9mZnNldCIsInN1YnRyYWN0IiwiYWJzIiwiQ2lyY2xlVG9vbCIsInNjYWxlIiwiZ2V0RGlzdGFuY2UiLCJTZWdtZW50UGF0aFRvb2wiLCJtb2RpZmllcnMiLCJzaGlmdCIsImdldFByb3BzIiwibnVtMSIsIm51bTIiLCJjYWxsQWxsSGFuZGxlcnMiLCJoYW5kbGVycyIsImhhbmRsZXIiLCJQYW5BbmRTY3JvbGwiLCJvbldoZWVsIiwiZGVsdGFZIiwib25ab29tIiwibWVyZ2VQcm9wcyIsInN0YXRlIiwiem9vbSIsInZpZXdQcm9wcyIsImtleSIsImRyYWdnYWJsZSIsIm9uUGFuRW5hYmxlZCIsImNhbnZhc1Byb3BzIiwic2V0U3RhdGUiLCJvblBhbkRpc2FibGVkIiwiZHJhZ1N0YXJ0IiwidmlldyIsIm11bHRpcGx5Iiwiem9vbUxldmVsIiwiY2hpbGRyZW4iLCJFbGxpcHNlVG9vbCIsIkVsbGlwc2UiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFzQnFCQTs7Ozs7Ozs7Ozs7Ozs7O1VBYW5CQzs7Ozs7RUFidUNDOztBQUFwQkYsU0FDWkcsZUFBZTtBQUNwQkMsRUFBQUEsU0FBUyxFQUFFLHFCQUFNLEVBREc7QUFFcEJDLEVBQUFBLE9BQU8sRUFBRSxtQkFBTSxFQUZLO0FBR3BCQyxFQUFBQSxXQUFXLEVBQUUsdUJBQU0sRUFIQztBQUlwQkMsRUFBQUEsV0FBVyxFQUFFLHVCQUFNLEVBSkM7QUFLcEJDLEVBQUFBLFNBQVMsRUFBRSxxQkFBTSxFQUxHO0FBTXBCQyxFQUFBQSxVQUFVLEVBQUUsc0JBQU0sRUFORTtBQU9wQkMsRUFBQUEsU0FBUyxFQUFFLHFCQUFNLEVBUEc7QUFRcEJDLEVBQUFBLFlBQVksRUFBRSx3QkFBTSxFQVJBO0FBU3BCQyxFQUFBQSxlQUFlLEVBQUUsMkJBQU07QUFUSDs7O0lDZmhCQyxPQUFxQkM7SUFBZkMsYUFBZUQ7QUFTN0IsSUFBTUUsZUFBZSxHQUFHLENBQXhCOztJQUlNQyxtQkFETEY7Ozs7Ozs7Ozs7Ozs7Ozs7VUFTQ1QsY0FBYyxVQUFDWSxTQUFELEVBQTBCO0FBQUEsd0JBQ2dCLE1BQUtDLEtBRHJCO0FBQUEsVUFDOUJDLFNBRDhCLGVBQzlCQSxTQUQ4QjtBQUFBLFVBQ25CZCxXQURtQixlQUNuQkEsV0FEbUI7QUFBQSxVQUNORyxVQURNLGVBQ05BLFVBRE07QUFBQSxVQUNNWSxLQUROLGVBQ01BLEtBRE47O0FBRXRDLFVBQUlILFNBQVMsQ0FBQ0ksS0FBVixDQUFnQkMsTUFBaEIsS0FBMkJQLGVBQS9CLEVBQWdEO0FBQzlDLFlBQU1mLElBQUksR0FBRyxJQUFJb0IsS0FBSyxDQUFDRyxJQUFWLENBQWVKLFNBQWYsQ0FBYjtBQUNBLGNBQUtuQixJQUFMLEdBQVlBLElBQVo7QUFDQVEsUUFBQUEsVUFBVSxDQUFDUixJQUFELENBQVY7QUFDRDs7QUFDREssTUFBQUEsV0FBVyxDQUFDWSxTQUFELENBQVg7QUFDRDs7VUFFRFgsY0FBYyxVQUFDVyxTQUFELEVBQTBCO0FBQUEsVUFDOUJYLFdBRDhCLEdBQ2QsTUFBS1ksS0FEUyxDQUM5QlosV0FEOEI7O0FBRXRDLFVBQUlXLFNBQVMsQ0FBQ0ksS0FBVixDQUFnQkcsT0FBaEIsS0FBNEIsQ0FBaEMsRUFBbUM7QUFDakMsY0FBS3hCLElBQUwsQ0FBVXlCLEdBQVYsQ0FBY1IsU0FBUyxDQUFDUyxLQUF4QjtBQUNEOztBQUNEcEIsTUFBQUEsV0FBVyxDQUFDVyxTQUFELENBQVg7QUFDRDs7VUFFRFYsWUFBWSxVQUFDVSxTQUFELEVBQTBCO0FBQUE7QUFBQSxVQUM1QmpCLElBRDRCLHlCQUM1QkEsSUFENEI7O0FBQUEseUJBRUgsTUFBS2tCLEtBRkY7QUFBQSxVQUU1QlgsU0FGNEIsZ0JBRTVCQSxTQUY0QjtBQUFBLFVBRWpCRSxTQUZpQixnQkFFakJBLFNBRmlCOztBQUdwQyxVQUFJVCxJQUFKLEVBQVU7QUFDUlMsUUFBQUEsU0FBUyxDQUFDVCxJQUFELENBQVQ7QUFDQSxjQUFLQSxJQUFMLEdBQVksSUFBWjtBQUNEOztBQUNETyxNQUFBQSxTQUFTLENBQUNVLFNBQUQsQ0FBVDtBQUNEOzs7Ozs7OzZCQUVRO0FBQUEseUJBR0gsS0FBS0MsS0FIRjtBQUFBLFVBRUxDLFNBRkssZ0JBRUxBLFNBRks7QUFBQSxVQUVNZCxXQUZOLGdCQUVNQSxXQUZOO0FBQUEsVUFFbUJDLFdBRm5CLGdCQUVtQkEsV0FGbkI7QUFBQSxVQUVnQ0MsU0FGaEMsZ0JBRWdDQSxTQUZoQztBQUFBLFVBRTJDRSxTQUYzQyxnQkFFMkNBLFNBRjNDO0FBQUEsVUFFc0RXLEtBRnRELGdCQUVzREEsS0FGdEQ7QUFBQSxVQUU2RE8sUUFGN0QsZ0JBRTZEQSxRQUY3RDtBQUFBLFVBRTBFQyxJQUYxRTs7QUFJUCwwQkFDRUMsb0JBQUMsSUFBRDtBQUNFLFFBQUEsR0FBRyxFQUFFRixRQURQO0FBRUUsUUFBQSxXQUFXLEVBQUUsRUFGZjtBQUdFLFFBQUEsV0FBVyxFQUFFLEtBQUt0QixXQUhwQjtBQUlFLFFBQUEsV0FBVyxFQUFFLEtBQUtDLFdBSnBCO0FBS0UsUUFBQSxTQUFTLEVBQUUsS0FBS0M7QUFMbEIsU0FNTXFCLElBTk4sRUFERjtBQVVEOzs7O0VBbEQ0QjdCLG1CQUN0QkcsaURBQ0ZILFFBQVEsQ0FBQ0c7QUFDWmlCLEVBQUFBLFNBQVMsRUFBRTtBQUNUVyxJQUFBQSxXQUFXLEVBQUU7QUFESjs7O0FBa0RmLGlDQUFlN0IsZ0JBQUEsQ0FDZ0IsVUFBQ2lCLEtBQUQsRUFBUWEsR0FBUjtBQUFBLHNCQUFnQkYsb0JBQUMsZ0JBQUQ7QUFBa0IsSUFBQSxRQUFRLEVBQUVFO0FBQTVCLEtBQXFDYixLQUFyQyxFQUFoQjtBQUFBLENBRGhCLENBQWY7O0lDckVRYyxRQUF1Qm5CO0lBQWhCb0IsUUFBZ0JwQjtJQUFUcUIsT0FBU3JCOztBQWUvQixJQUFNc0IsSUFBSSxHQUFHLFNBQVBBLElBQU8sT0FBaUs7QUFBQSxNQUE5SkMsS0FBOEosUUFBOUpBLEtBQThKO0FBQUEsTUFBdkpDLE1BQXVKLFFBQXZKQSxNQUF1SjtBQUFBLHNCQUEvSUMsR0FBK0k7QUFBQSxNQUEvSUEsR0FBK0kseUJBQXpJLENBQXlJO0FBQUEsdUJBQXRJQyxJQUFzSTtBQUFBLE1BQXRJQSxJQUFzSSwwQkFBL0gsQ0FBK0g7QUFBQSx3QkFBNUhDLEtBQTRIO0FBQUEsTUFBNUhBLEtBQTRILDJCQUFwSEQsSUFBSSxHQUFHSCxLQUE2RztBQUFBLHlCQUF0R0ssTUFBc0c7QUFBQSxNQUF0R0EsTUFBc0csNEJBQTdGSCxHQUFHLEdBQUdELE1BQXVGO0FBQUEsMkJBQS9FSyxRQUErRTtBQUFBLE1BQS9FQSxRQUErRSw4QkFBcEUsRUFBb0U7QUFBQSw4QkFBaEVaLFdBQWdFO0FBQUEsTUFBaEVBLFdBQWdFLGlDQUFsRCxTQUFrRDtBQUFBLDhCQUF2Q2EsV0FBdUM7QUFBQSxNQUF2Q0EsV0FBdUMsaUNBQXpCLENBQXlCO0FBQUEsTUFBdEJoQixRQUFzQixRQUF0QkEsUUFBc0I7QUFDNUssTUFBTWlCLENBQUMsR0FBR0MsSUFBSSxDQUFDQyxJQUFMLENBQVVQLElBQUksR0FBR0csUUFBakIsSUFBNkJBLFFBQXZDO0FBQ0EsTUFBTUssQ0FBQyxHQUFHRixJQUFJLENBQUNDLElBQUwsQ0FBVVIsR0FBRyxHQUFHSSxRQUFoQixJQUE0QkEsUUFBdEM7QUFDQSxNQUFNTSxJQUFJLEdBQUdILElBQUksQ0FBQ0MsSUFBTCxDQUFVLENBQUNOLEtBQUssR0FBR0QsSUFBVCxJQUFpQkcsUUFBM0IsQ0FBYjtBQUNBLE1BQU1PLElBQUksR0FBR0osSUFBSSxDQUFDQyxJQUFMLENBQVUsQ0FBQ0wsTUFBTSxHQUFHSCxHQUFWLElBQWlCSSxRQUEzQixDQUFiO0FBQ0EsTUFBTVEsYUFBYSxHQUFHLEVBQXRCO0FBQ0EsTUFBTUMsZUFBZSxHQUFHLEVBQXhCOztBQUNBLE9BQUssSUFBSUMsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsSUFBSUosSUFBckIsRUFBMkJJLENBQUMsSUFBSSxDQUFoQyxFQUFtQztBQUNqQyxRQUFNQyxRQUFRLEdBQUdULENBQUMsR0FBSVEsQ0FBQyxHQUFHVixRQUExQjtBQUNBUSxJQUFBQSxhQUFhLENBQUNJLElBQWQsZUFBbUJ6QixvQkFBQyxJQUFEO0FBQ2pCLE1BQUEsR0FBRyxFQUFFdUIsQ0FEWTtBQUVqQixNQUFBLElBQUksRUFBRSxDQUFDQyxRQUFELEVBQVdmLEdBQVgsQ0FGVztBQUdqQixNQUFBLEVBQUUsRUFBRSxDQUFDZSxRQUFELEVBQVdaLE1BQVgsQ0FIYTtBQUlqQixNQUFBLFdBQVcsRUFBRVgsV0FKSTtBQUtqQixNQUFBLFdBQVcsRUFBRWE7QUFMSSxNQUFuQjtBQU9EOztBQUNELE9BQUssSUFBSVMsRUFBQyxHQUFHLENBQWIsRUFBZ0JBLEVBQUMsSUFBSUgsSUFBckIsRUFBMkJHLEVBQUMsSUFBSSxDQUFoQyxFQUFtQztBQUNqQyxRQUFNQyxTQUFRLEdBQUdOLENBQUMsR0FBSUssRUFBQyxHQUFHVixRQUExQjs7QUFDQVMsSUFBQUEsZUFBZSxDQUFDRyxJQUFoQixlQUFxQnpCLG9CQUFDLElBQUQ7QUFDbkIsTUFBQSxHQUFHLEVBQUV1QixFQURjO0FBRW5CLE1BQUEsSUFBSSxFQUFFLENBQUNiLElBQUQsRUFBT2MsU0FBUCxDQUZhO0FBR25CLE1BQUEsRUFBRSxFQUFFLENBQUNiLEtBQUQsRUFBUWEsU0FBUixDQUhlO0FBSW5CLE1BQUEsV0FBVyxFQUFFdkIsV0FKTTtBQUtuQixNQUFBLFdBQVcsRUFBRWE7QUFMTSxNQUFyQjtBQU9EOztBQUNELHNCQUNFZCxvQkFBQyxLQUFEO0FBQU8sSUFBQSxHQUFHLEVBQUVGO0FBQVosa0JBQ0VFLG9CQUFDLEtBQUQsUUFDR3FCLGFBREgsQ0FERixlQUlFckIsb0JBQUMsS0FBRCxRQUNHc0IsZUFESCxDQUpGLENBREY7QUFVRCxDQXJDRDs7QUF1Q0EscUJBQWVsRCxnQkFBQSxDQUNpQixVQUFDaUIsS0FBRCxFQUFRYSxHQUFSO0FBQUEsc0JBQWdCRixvQkFBQyxJQUFEO0FBQU0sSUFBQSxRQUFRLEVBQUVFO0FBQWhCLEtBQXlCYixLQUF6QixFQUFoQjtBQUFBLENBRGpCLENBQWY7OztJQ3BEUU4sU0FBcUJDO0lBQWZDLGVBQWVEO0FBUzdCLElBQU1FLGlCQUFlLEdBQUcsQ0FBeEI7O0lBSU13QyxXQURMekM7Ozs7Ozs7Ozs7Ozs7Ozs7VUFTQ1QsY0FBYyxVQUFDWSxTQUFELEVBQTBCO0FBQUEsd0JBQ2dCLE1BQUtDLEtBRHJCO0FBQUEsVUFDOUJDLFNBRDhCLGVBQzlCQSxTQUQ4QjtBQUFBLFVBQ25CZCxXQURtQixlQUNuQkEsV0FEbUI7QUFBQSxVQUNORyxVQURNLGVBQ05BLFVBRE07QUFBQSxVQUNNWSxLQUROLGVBQ01BLEtBRE47O0FBRXRDLFVBQUlILFNBQVMsQ0FBQ0ksS0FBVixDQUFnQkMsTUFBaEIsS0FBMkJQLGlCQUEvQixFQUFnRDtBQUM5QyxZQUFNZixJQUFJLEdBQUcsSUFBSW9CLEtBQUssQ0FBQ0csSUFBVixDQUFlSixTQUFmLENBQWI7QUFDQW5CLFFBQUFBLElBQUksQ0FBQ3lCLEdBQUwsQ0FBU1IsU0FBUyxDQUFDUyxLQUFuQjtBQUNBLGNBQUsxQixJQUFMLEdBQVlBLElBQVo7QUFDQVEsUUFBQUEsVUFBVSxDQUFDUixJQUFELENBQVY7QUFDRDs7QUFDREssTUFBQUEsV0FBVyxDQUFDWSxTQUFELENBQVg7QUFDRDs7VUFFRFgsY0FBYyxVQUFDVyxTQUFELEVBQTBCO0FBQUE7QUFBQSxVQUM5QmpCLElBRDhCLHlCQUM5QkEsSUFEOEI7O0FBQUEsVUFFOUJNLFdBRjhCLEdBRWQsTUFBS1ksS0FGUyxDQUU5QlosV0FGOEI7O0FBR3RDLFVBQUlXLFNBQVMsQ0FBQ0ksS0FBVixDQUFnQkcsT0FBaEIsS0FBNEIsQ0FBaEMsRUFBbUM7QUFDakN4QixRQUFBQSxJQUFJLENBQUN3RCxhQUFMLENBQW1CLENBQW5CO0FBQ0F4RCxRQUFBQSxJQUFJLENBQUN5RCxVQUFMLENBQWdCeEMsU0FBUyxDQUFDUyxLQUExQjtBQUNBMUIsUUFBQUEsSUFBSSxDQUFDMEQsUUFBTCxHQUFnQixJQUFoQjtBQUNEOztBQUNEcEQsTUFBQUEsV0FBVyxDQUFDVyxTQUFELENBQVg7QUFDRDs7VUFFRFYsWUFBWSxVQUFDVSxTQUFELEVBQTBCO0FBQUE7QUFBQSxVQUM1QmpCLElBRDRCLDBCQUM1QkEsSUFENEI7O0FBQUEseUJBRUgsTUFBS2tCLEtBRkY7QUFBQSxVQUU1QlgsU0FGNEIsZ0JBRTVCQSxTQUY0QjtBQUFBLFVBRWpCRSxTQUZpQixnQkFFakJBLFNBRmlCOztBQUdwQyxVQUFJVCxJQUFKLEVBQVU7QUFDUkEsUUFBQUEsSUFBSSxDQUFDMEQsUUFBTCxHQUFnQixLQUFoQjtBQUNBakQsUUFBQUEsU0FBUyxDQUFDVCxJQUFELENBQVQ7QUFDQSxjQUFLQSxJQUFMLEdBQVksSUFBWjtBQUNEOztBQUNETyxNQUFBQSxTQUFTLENBQUNVLFNBQUQsQ0FBVDtBQUNEOzs7Ozs7OzZCQUVRO0FBQUEseUJBR0gsS0FBS0MsS0FIRjtBQUFBLFVBRUxDLFNBRkssZ0JBRUxBLFNBRks7QUFBQSxVQUVNZCxXQUZOLGdCQUVNQSxXQUZOO0FBQUEsVUFFbUJDLFdBRm5CLGdCQUVtQkEsV0FGbkI7QUFBQSxVQUVnQ0MsU0FGaEMsZ0JBRWdDQSxTQUZoQztBQUFBLFVBRTJDRSxTQUYzQyxnQkFFMkNBLFNBRjNDO0FBQUEsVUFFc0RrQixRQUZ0RCxnQkFFc0RBLFFBRnREO0FBQUEsVUFFbUVDLElBRm5FOztBQUlQLDBCQUNFQyxvQkFBQ2pCLE1BQUQ7QUFDRSxRQUFBLEdBQUcsRUFBRWUsUUFEUDtBQUVFLFFBQUEsV0FBVyxFQUFFLEtBQUt0QixXQUZwQjtBQUdFLFFBQUEsV0FBVyxFQUFFLEtBQUtDLFdBSHBCO0FBSUUsUUFBQSxTQUFTLEVBQUUsS0FBS0M7QUFKbEIsU0FLTXFCLElBTE4sRUFERjtBQVNEOzs7O0VBdERvQjdCLHFCQUNkRyxpREFDRkgsUUFBUSxDQUFDRztBQUNaaUIsRUFBQUEsU0FBUyxFQUFFO0FBQ1RXLElBQUFBLFdBQVcsRUFBRTtBQURKOzs7QUFzRGYseUJBQWU3QixnQkFBQSxDQUNnQixVQUFDaUIsS0FBRCxFQUFRYSxHQUFSO0FBQUEsc0JBQWdCRixvQkFBQyxRQUFEO0FBQVUsSUFBQSxRQUFRLEVBQUVFO0FBQXBCLEtBQTZCYixLQUE3QixFQUFoQjtBQUFBLENBRGhCLENBQWY7OztJQ3RFUU4sU0FBcUJDO0lBQWZDLGVBQWVEO0FBVTdCLElBQU1FLGlCQUFlLEdBQUcsQ0FBeEI7O0lBSU00QyxjQURMN0M7Ozs7Ozs7Ozs7Ozs7Ozs7VUFxQkNULGNBQWMsVUFBQ1ksU0FBRCxFQUEwQjtBQUN0QyxVQUFJQSxTQUFTLENBQUNJLEtBQVYsQ0FBZ0JDLE1BQWhCLEtBQTJCUCxpQkFBL0IsRUFBZ0Q7QUFBQTtBQUFBLFlBQ3RDZixJQURzQyx5QkFDdENBLElBRHNDOztBQUU5QyxZQUFJLENBQUNBLElBQUwsRUFBVztBQUNULGdCQUFLNEQsUUFBTDs7QUFDQSxnQkFBSzFDLEtBQUwsQ0FBV1YsVUFBWCxDQUFzQlIsSUFBdEI7QUFDRDs7QUFDRCxZQUFJLE1BQUs2RCxlQUFMLElBQXdCLElBQTVCLEVBQWtDO0FBQ2hDLGdCQUFLbkQsWUFBTCxDQUFrQk8sU0FBbEI7QUFDRCxTQUZELE1BRU87QUFDTCxnQkFBS1IsU0FBTDtBQUNEO0FBQ0Y7O0FBQ0QsWUFBS1MsS0FBTCxDQUFXYixXQUFYLENBQXVCWSxTQUF2QjtBQUNEOztVQTBFRDZDO1VBRUFEOzs7Ozs7eUNBckdxQjtBQUFBLFVBQ1g3RCxJQURXLEdBQ2EsSUFEYixDQUNYQSxJQURXO0FBQUEsVUFDTDhELE1BREssR0FDYSxJQURiLENBQ0xBLE1BREs7QUFBQSxVQUNHNUMsS0FESCxHQUNhLElBRGIsQ0FDR0EsS0FESDtBQUFBLFVBRVhDLFNBRlcsR0FFYUQsS0FGYixDQUVYQyxTQUZXO0FBQUEsVUFFQTRDLFFBRkEsR0FFYTdDLEtBRmIsQ0FFQTZDLFFBRkE7O0FBR25CLFVBQUkvRCxJQUFKLEVBQVU7QUFDUixhQUFLZ0UsV0FBTCxDQUFpQkQsUUFBakI7QUFDQUUsUUFBQUEsTUFBTSxDQUFDQyxNQUFQLENBQWNsRSxJQUFkLEVBQW9CbUIsU0FBcEI7QUFDRCxPQUhELE1BR08sSUFBSTJDLE1BQUosRUFBWTtBQUNqQixhQUFLRixRQUFMO0FBQ0Q7QUFDRjs7OytCQWtCVTtBQUFBLHdCQUM4QixLQUFLMUMsS0FEbkM7QUFBQSxVQUNEQyxTQURDLGVBQ0RBLFNBREM7QUFBQSxVQUNVNEMsUUFEVixlQUNVQSxRQURWO0FBQUEsVUFDb0IzQyxLQURwQixlQUNvQkEsS0FEcEI7QUFBQSxVQUVERyxJQUZDLEdBRVFILEtBRlIsQ0FFREcsSUFGQztBQUdULFVBQU12QixJQUFJLEdBQUcsSUFBSXVCLElBQUosQ0FBU0osU0FBVCxDQUFiO0FBQ0EsV0FBS25CLElBQUwsR0FBWUEsSUFBWjtBQUNBLFdBQUtnRSxXQUFMLENBQWlCRCxRQUFqQjtBQUNEOzs7Z0NBRVdBLFVBQWtCO0FBQUE7O0FBQUEsVUFDcEIvRCxJQURvQixHQUNYLElBRFcsQ0FDcEJBLElBRG9CO0FBRTVCLFdBQUttRSxZQUFMO0FBQ0FuRSxNQUFBQSxJQUFJLENBQUMrRCxRQUFMLEdBQWdCQSxRQUFoQjtBQUNBL0QsTUFBQUEsSUFBSSxDQUFDb0UsUUFBTCxDQUFjQyxPQUFkLENBQXNCLFVBQUFDLE9BQU87QUFBQSxlQUFJLE1BQUksQ0FBQ0MsWUFBTCxDQUFrQkQsT0FBbEIsQ0FBSjtBQUFBLE9BQTdCO0FBQ0Q7OztpQ0FFWXJELFdBQXNCO0FBQUEsVUFDekJqQixJQUR5QixHQUNoQixJQURnQixDQUN6QkEsSUFEeUI7QUFFakNBLE1BQUFBLElBQUksQ0FBQ3lCLEdBQUwsQ0FBU1IsU0FBUyxDQUFDUyxLQUFuQjtBQUNBLFVBQU00QyxPQUFPLEdBQUd0RSxJQUFJLENBQUN3RSxXQUFyQjtBQUNBLFdBQUtELFlBQUwsQ0FBa0JELE9BQWxCO0FBQ0EsV0FBS3BELEtBQUwsQ0FBV1IsWUFBWCxDQUF3QjRELE9BQXhCLEVBQWlDdEUsSUFBakM7QUFDRDs7O2dDQUVXO0FBQUEsVUFDRjZELGVBREUsR0FDZ0MsSUFEaEMsQ0FDRkEsZUFERTtBQUFBLFVBQ2U3RCxJQURmLEdBQ2dDLElBRGhDLENBQ2VBLElBRGY7QUFBQSxVQUNxQjhELE1BRHJCLEdBQ2dDLElBRGhDLENBQ3FCQSxNQURyQjtBQUFBLHlCQUU2QixLQUFLNUMsS0FGbEM7QUFBQSxVQUVGUCxlQUZFLGdCQUVGQSxlQUZFO0FBQUEsVUFFZUYsU0FGZixnQkFFZUEsU0FGZjtBQUFBLFVBR0ZnRSxLQUhFLEdBR1FaLGVBSFIsQ0FHRlksS0FIRTtBQUlWLFVBQU1MLFFBQVEsR0FBR3BFLElBQUksQ0FBQzBFLGNBQUwsQ0FBb0IsQ0FBcEIsRUFBdUJELEtBQXZCLENBQWpCOztBQUNBLFVBQUlMLFFBQVEsQ0FBQ08sTUFBYixFQUFxQjtBQUNuQmhFLFFBQUFBLGVBQWUsQ0FBQ3lELFFBQUQsRUFBV3BFLElBQVgsQ0FBZjtBQUNEOztBQUNEQSxNQUFBQSxJQUFJLENBQUM0RSxNQUFMLEdBQWMsSUFBZDtBQUNBNUUsTUFBQUEsSUFBSSxDQUFDMEQsUUFBTCxHQUFnQixLQUFoQjtBQUNBakQsTUFBQUEsU0FBUyxDQUFDVCxJQUFELENBQVQ7QUFDQSxXQUFLQSxJQUFMLEdBQVksSUFBWjtBQUNBLFdBQUs2RCxlQUFMLEdBQXVCLElBQXZCOztBQUNBLFVBQUlDLE1BQUosRUFBWTtBQUNWQSxRQUFBQSxNQUFNLENBQUNlLE1BQVA7QUFDRDtBQUNGOzs7aUNBRVlQLFNBQWtCO0FBQUE7O0FBQUEsVUFDckJsRCxLQURxQixHQUNYLEtBQUtGLEtBRE0sQ0FDckJFLEtBRHFCO0FBQUEsVUFFckJHLElBRnFCLEdBRUlILEtBRkosQ0FFckJHLElBRnFCO0FBQUEsVUFFZlUsS0FGZSxHQUVJYixLQUZKLENBRWZhLEtBRmU7QUFBQSxVQUVSNkMsT0FGUSxHQUVJMUQsS0FGSixDQUVSMEQsT0FGUTtBQUFBLFVBR3JCOUUsSUFIcUIsR0FHSixJQUhJLENBR3JCQSxJQUhxQjtBQUFBLFVBR2Y4RCxNQUhlLEdBR0osSUFISSxDQUdmQSxNQUhlOztBQUk3QixVQUFJLENBQUNBLE1BQUwsRUFBYTtBQUNYLGFBQUtBLE1BQUwsR0FBYyxJQUFJN0IsS0FBSixFQUFkO0FBQ0E2QyxRQUFBQSxPQUFPLENBQUNDLE1BQVIsQ0FBZUMsVUFBZixDQUEwQkMsUUFBMUIsQ0FBbUMsS0FBS25CLE1BQXhDO0FBQ0Q7O0FBQ0QsVUFBTW9CLE1BQU0sR0FBRyxJQUFJM0QsSUFBSSxDQUFDNEQsTUFBVCxDQUFnQjtBQUM3QkMsUUFBQUEsTUFBTSxFQUFFZCxPQUFPLENBQUM1QyxLQURhO0FBRTdCMkQsUUFBQUEsTUFBTSxFQUFFLENBRnFCO0FBRzdCQyxRQUFBQSxTQUFTLEVBQUUsT0FIa0I7QUFJN0JDLFFBQUFBLE9BQU8sRUFBRTtBQUpvQixPQUFoQixDQUFmO0FBTUFMLE1BQUFBLE1BQU0sQ0FBQ00sRUFBUCxDQUFVLFdBQVYsRUFBdUIsWUFBTTtBQUMzQixZQUFJLENBQUN4RixJQUFJLENBQUM0RSxNQUFOLElBQ0csQ0FBQzVFLElBQUksQ0FBQ3dFLFdBQUwsQ0FBaUI5QyxLQUFqQixDQUF1QitELE1BQXZCLENBQThCUCxNQUFNLENBQUM3QixRQUFyQyxDQURKLElBRUdyRCxJQUFJLENBQUMwRixRQUFMLENBQWNSLE1BQU0sQ0FBQzdCLFFBQXJCLENBRlAsRUFFdUM7QUFDckMsVUFBQSxNQUFJLENBQUNRLGVBQUwsR0FBdUJTLE9BQXZCO0FBQ0Q7QUFDRixPQU5EO0FBT0EsV0FBS1IsTUFBTCxDQUFZbUIsUUFBWixDQUFxQkMsTUFBckI7QUFDRDs7O21DQUVjO0FBQ2IsVUFBSSxLQUFLcEIsTUFBVCxFQUFpQjtBQUNmLGFBQUtBLE1BQUwsQ0FBWWUsTUFBWjtBQUNBLGFBQUtmLE1BQUwsR0FBYyxJQUFkO0FBQ0Q7QUFDRjs7OzZCQU1RO0FBQUEseUJBR0gsS0FBSzVDLEtBSEY7QUFBQSxVQUVMQyxTQUZLLGdCQUVMQSxTQUZLO0FBQUEsVUFFTWQsV0FGTixnQkFFTUEsV0FGTjtBQUFBLFVBRW1CSSxTQUZuQixnQkFFbUJBLFNBRm5CO0FBQUEsVUFFOEJDLFlBRjlCLGdCQUU4QkEsWUFGOUI7QUFBQSxVQUU0Q0MsZUFGNUMsZ0JBRTRDQSxlQUY1QztBQUFBLFVBRTZEUyxLQUY3RCxnQkFFNkRBLEtBRjdEO0FBQUEsVUFFb0VPLFFBRnBFLGdCQUVvRUEsUUFGcEU7QUFBQSxVQUVpRkMsSUFGakY7O0FBSVAsMEJBQ0VDLG9CQUFDakIsTUFBRDtBQUNFLFFBQUEsR0FBRyxFQUFFZSxRQURQO0FBRUUsUUFBQSxXQUFXLEVBQUUsS0FBS3RCO0FBRnBCLFNBR011QixJQUhOLEVBREY7QUFPRDs7OztFQTNIdUI3QixxQkFDakJHLGlEQUNGSCxRQUFRLENBQUNHO0FBQ1ppQixFQUFBQSxTQUFTLEVBQUU7QUFDVFcsSUFBQUEsV0FBVyxFQUFFLE9BREo7QUFFVDRCLElBQUFBLFFBQVEsRUFBRTtBQUZEOzs7QUEySGYsNEJBQWV6RCxnQkFBQSxDQUNnQixVQUFDaUIsS0FBRCxFQUFRYSxHQUFSO0FBQUEsc0JBQWdCRixvQkFBQyxXQUFEO0FBQWEsSUFBQSxRQUFRLEVBQUVFO0FBQXZCLEtBQWdDYixLQUFoQyxFQUFoQjtBQUFBLENBRGhCLENBQWY7OztJQzVJUU4sU0FBcUJDO0lBQWZDLGVBQWVEO0FBUzdCLElBQU1FLGlCQUFlLEdBQUcsQ0FBeEI7O0lBSU00RSxnQkFETDdFOzs7Ozs7Ozs7Ozs7Ozs7O1VBVUNULGNBQWMsVUFBQ1ksU0FBRCxFQUEwQjtBQUFBLHdCQUNnQixNQUFLQyxLQURyQjtBQUFBLFVBQzlCQyxTQUQ4QixlQUM5QkEsU0FEOEI7QUFBQSxVQUNuQmQsV0FEbUIsZUFDbkJBLFdBRG1CO0FBQUEsVUFDTkcsVUFETSxlQUNOQSxVQURNO0FBQUEsVUFDTVksS0FETixlQUNNQSxLQUROOztBQUV0QyxVQUFJSCxTQUFTLENBQUNJLEtBQVYsQ0FBZ0JDLE1BQWhCLEtBQTJCUCxpQkFBL0IsRUFBZ0Q7QUFBQSxZQUN0Q1EsSUFEc0MsR0FDdEJILEtBRHNCLENBQ3RDRyxJQURzQztBQUFBLFlBQ2hDcUUsS0FEZ0MsR0FDdEJ4RSxLQURzQixDQUNoQ3dFLEtBRGdDO0FBRTlDLFlBQU1DLEtBQUssR0FBRzVFLFNBQVMsQ0FBQ1MsS0FBeEI7QUFDQSxZQUFNMUIsSUFBSSxHQUFHLElBQUl1QixJQUFJLENBQUN1RSxTQUFULENBQW1CO0FBQzlCcEUsVUFBQUEsS0FBSyxFQUFFbUUsS0FEdUI7QUFFOUJFLFVBQUFBLElBQUksRUFBRSxDQUFDLENBQUQsRUFBSSxDQUFKLENBRndCO0FBRzlCVCxVQUFBQSxTQUFTLEVBQUVuRSxTQUFTLENBQUM2RSxpQkFBVixJQUErQixJQUFJSixLQUFKLENBQVUsR0FBVixFQUFlLEdBQWYsRUFBb0IsQ0FBcEIsRUFBdUIsSUFBdkIsQ0FIWjtBQUk5QmxDLFVBQUFBLFFBQVEsRUFBRTtBQUpvQixTQUFuQixDQUFiO0FBTUEsY0FBSzFELElBQUwsR0FBWUEsSUFBWjtBQUNBLGNBQUs2RixLQUFMLEdBQWFBLEtBQWI7QUFDQXJGLFFBQUFBLFVBQVUsQ0FBQ1IsSUFBRCxDQUFWO0FBQ0Q7O0FBQ0RLLE1BQUFBLFdBQVcsQ0FBQ1ksU0FBRCxDQUFYO0FBQ0Q7O1VBRURYLGNBQWMsVUFBQ1csU0FBRCxFQUEwQjtBQUFBLFVBQzlCWCxXQUQ4QixHQUNkLE1BQUtZLEtBRFMsQ0FDOUJaLFdBRDhCOztBQUV0QyxVQUFJVyxTQUFTLENBQUNJLEtBQVYsQ0FBZ0JHLE9BQWhCLEtBQTRCLENBQWhDLEVBQW1DO0FBQUE7QUFBQSxZQUN6QnhCLElBRHlCLHlCQUN6QkEsSUFEeUI7QUFBQSxZQUNuQjZGLEtBRG1CLHlCQUNuQkEsS0FEbUI7O0FBQUEsWUFFekJYLE1BRnlCLEdBRWRsRixJQUZjLENBRXpCa0YsTUFGeUI7QUFHakMsWUFBTWUsTUFBTSxHQUFHaEYsU0FBUyxDQUFDUyxLQUFWLENBQWdCd0UsUUFBaEIsQ0FBeUJMLEtBQXpCLENBQWY7QUFDQSxZQUFNekQsS0FBSyxHQUFHUyxJQUFJLENBQUNzRCxHQUFMLENBQVNGLE1BQU0sQ0FBQ3JELENBQWhCLENBQWQ7QUFDQSxZQUFNUCxNQUFNLEdBQUdRLElBQUksQ0FBQ3NELEdBQUwsQ0FBU0YsTUFBTSxDQUFDbEQsQ0FBaEIsQ0FBZjs7QUFDQSxZQUFJa0QsTUFBTSxDQUFDckQsQ0FBUCxHQUFXLENBQWYsRUFBa0I7QUFDaEJzQyxVQUFBQSxNQUFNLENBQUMzQyxJQUFQLEdBQWN0QixTQUFTLENBQUNTLEtBQVYsQ0FBZ0JrQixDQUE5QjtBQUNBc0MsVUFBQUEsTUFBTSxDQUFDMUMsS0FBUCxHQUFlcUQsS0FBSyxDQUFDakQsQ0FBckI7QUFDRCxTQUhELE1BR087QUFDTHNDLFVBQUFBLE1BQU0sQ0FBQzNDLElBQVAsR0FBY3NELEtBQUssQ0FBQ2pELENBQXBCO0FBQ0Q7O0FBQ0QsWUFBSXFELE1BQU0sQ0FBQ2xELENBQVAsR0FBVyxDQUFmLEVBQWtCO0FBQ2hCbUMsVUFBQUEsTUFBTSxDQUFDNUMsR0FBUCxHQUFhdUQsS0FBSyxDQUFDOUMsQ0FBbkI7QUFDQW1DLFVBQUFBLE1BQU0sQ0FBQ3pDLE1BQVAsR0FBZ0J4QixTQUFTLENBQUNTLEtBQVYsQ0FBZ0JxQixDQUFoQztBQUNELFNBSEQsTUFHTztBQUNMbUMsVUFBQUEsTUFBTSxDQUFDNUMsR0FBUCxHQUFhckIsU0FBUyxDQUFDUyxLQUFWLENBQWdCcUIsQ0FBN0I7QUFDRDs7QUFDRCxZQUFJWCxLQUFLLEdBQUcsQ0FBWixFQUFlO0FBQ2I4QyxVQUFBQSxNQUFNLENBQUM5QyxLQUFQLEdBQWVBLEtBQWY7QUFDRDs7QUFDRCxZQUFJQyxNQUFNLEdBQUcsQ0FBYixFQUFnQjtBQUNkNkMsVUFBQUEsTUFBTSxDQUFDN0MsTUFBUCxHQUFnQkEsTUFBaEI7QUFDRDtBQUNGOztBQUNEL0IsTUFBQUEsV0FBVyxDQUFDVyxTQUFELENBQVg7QUFDRDs7VUFFRFYsWUFBWSxVQUFDYyxLQUFELEVBQXNCO0FBQUE7QUFBQSxVQUN4QnJCLElBRHdCLDBCQUN4QkEsSUFEd0I7O0FBQUEseUJBRVksTUFBS2tCLEtBRmpCO0FBQUEsVUFFeEJDLFNBRndCLGdCQUV4QkEsU0FGd0I7QUFBQSxVQUViWixTQUZhLGdCQUViQSxTQUZhO0FBQUEsVUFFRkUsU0FGRSxnQkFFRkEsU0FGRTs7QUFHaEMsVUFBSVQsSUFBSixFQUFVO0FBQ1JpRSxRQUFBQSxNQUFNLENBQUNDLE1BQVAsQ0FBY2xFLElBQWQ7QUFDRTBELFVBQUFBLFFBQVEsRUFBRTtBQURaLFdBRUt2QyxTQUZMO0FBSUFWLFFBQUFBLFNBQVMsQ0FBQ1QsSUFBRCxDQUFUO0FBQ0EsY0FBS0EsSUFBTCxHQUFZLElBQVo7QUFDQSxjQUFLNkYsS0FBTCxHQUFhLElBQWI7QUFDRDs7QUFDRHRGLE1BQUFBLFNBQVMsQ0FBQ2MsS0FBRCxDQUFUO0FBQ0Q7O1VBRUR3RTs7Ozs7OzZCQUVTO0FBQUEseUJBQ3VCLEtBQUszRSxLQUQ1QjtBQUFBLFVBQ0NTLFFBREQsZ0JBQ0NBLFFBREQ7QUFBQSxVQUNjQyxJQURkOztBQUVQLDBCQUNFQyxvQkFBQ2pCLE1BQUQsZUFDTWdCLElBRE47QUFFRSxRQUFBLEdBQUcsRUFBRUQsUUFGUDtBQUdFLFFBQUEsV0FBVyxFQUFFLEtBQUt0QixXQUhwQjtBQUlFLFFBQUEsV0FBVyxFQUFFLEtBQUtDLFdBSnBCO0FBS0UsUUFBQSxTQUFTLEVBQUUsS0FBS0M7QUFMbEIsU0FERjtBQVNEOzs7O0VBckZ5QlIscUJBQ25CRyxpREFDRkgsUUFBUSxDQUFDRztBQUNaaUIsRUFBQUEsU0FBUyxFQUFFO0FBQ1RtRSxJQUFBQSxTQUFTLEVBQUUsT0FERjtBQUVUeEQsSUFBQUEsV0FBVyxFQUFFO0FBRko7OztBQXFGZiw4QkFBZTdCLGdCQUFBLENBQ2dCLFVBQUNpQixLQUFELEVBQVFhLEdBQVI7QUFBQSxzQkFBZ0JGLG9CQUFDLGFBQUQ7QUFBZSxJQUFBLFFBQVEsRUFBRUU7QUFBekIsS0FBa0NiLEtBQWxDLEVBQWhCO0FBQUEsQ0FEaEIsQ0FBZjs7O0lDckdRTixTQUFxQkM7SUFBZkMsZUFBZUQ7QUFVN0IsSUFBTUUsaUJBQWUsR0FBRyxDQUF4Qjs7SUFJTXFGLGFBREx0Rjs7Ozs7Ozs7Ozs7Ozs7OztVQVVDVCxjQUFjLFVBQUNZLFNBQUQsRUFBMEI7QUFBQSx3QkFDZ0IsTUFBS0MsS0FEckI7QUFBQSxVQUM5QkMsU0FEOEIsZUFDOUJBLFNBRDhCO0FBQUEsVUFDbkJkLFdBRG1CLGVBQ25CQSxXQURtQjtBQUFBLFVBQ05HLFVBRE0sZUFDTkEsVUFETTtBQUFBLFVBQ01ZLEtBRE4sZUFDTUEsS0FETjs7QUFFdEMsVUFBSUgsU0FBUyxDQUFDSSxLQUFWLENBQWdCQyxNQUFoQixLQUEyQlAsaUJBQS9CLEVBQWdEO0FBQUEsWUFDdENRLElBRHNDLEdBQ3RCSCxLQURzQixDQUN0Q0csSUFEc0M7QUFBQSxZQUNoQ3FFLEtBRGdDLEdBQ3RCeEUsS0FEc0IsQ0FDaEN3RSxLQURnQztBQUU5QyxZQUFNNUYsSUFBSSxHQUFHLElBQUl1QixJQUFJLENBQUM0RCxNQUFULENBQWdCO0FBQzNCQyxVQUFBQSxNQUFNLEVBQUVuRSxTQUFTLENBQUNTLEtBRFM7QUFFM0IyRCxVQUFBQSxNQUFNLEVBQUUsQ0FGbUI7QUFHM0JDLFVBQUFBLFNBQVMsRUFBRW5FLFNBQVMsQ0FBQzZFLGlCQUFWLElBQStCLElBQUlKLEtBQUosQ0FBVSxHQUFWLEVBQWUsR0FBZixFQUFvQixDQUFwQixFQUF1QixJQUF2QixDQUhmO0FBSTNCbEMsVUFBQUEsUUFBUSxFQUFFO0FBSmlCLFNBQWhCLENBQWI7QUFNQSxjQUFLMUQsSUFBTCxHQUFZQSxJQUFaO0FBQ0FRLFFBQUFBLFVBQVUsQ0FBQ1IsSUFBRCxDQUFWO0FBQ0Q7O0FBQ0RLLE1BQUFBLFdBQVcsQ0FBQ1ksU0FBRCxDQUFYO0FBQ0Q7O1VBRURYLGNBQWMsVUFBQ1csU0FBRCxFQUEwQjtBQUFBLFVBQzlCWCxXQUQ4QixHQUNkLE1BQUtZLEtBRFMsQ0FDOUJaLFdBRDhCOztBQUV0QyxVQUFJVyxTQUFTLENBQUNJLEtBQVYsQ0FBZ0JHLE9BQWhCLEtBQTRCLENBQWhDLEVBQW1DO0FBQUE7QUFBQSxZQUN6QnhCLElBRHlCLHlCQUN6QkEsSUFEeUI7O0FBRWpDLFlBQU1xRyxLQUFLLEdBQUd4RCxJQUFJLENBQUNzRCxHQUFMLENBQVNsRixTQUFTLENBQUNTLEtBQVYsQ0FBZ0I0RSxXQUFoQixDQUE0QnRHLElBQUksQ0FBQ3FELFFBQWpDLEtBQThDckQsSUFBSSxDQUFDa0YsTUFBTCxDQUFZOUMsS0FBWixHQUFvQixDQUFsRSxDQUFULENBQWQ7O0FBQ0EsWUFBSWlFLEtBQUssR0FBRyxHQUFaLEVBQWlCO0FBQ2ZyRyxVQUFBQSxJQUFJLENBQUNxRyxLQUFMLENBQVdBLEtBQVg7QUFDRDtBQUNGOztBQUNEL0YsTUFBQUEsV0FBVyxDQUFDVyxTQUFELENBQVg7QUFDRDs7VUFFRFYsWUFBWSxVQUFDYyxLQUFELEVBQXNCO0FBQUE7QUFBQSxVQUN4QnJCLElBRHdCLDBCQUN4QkEsSUFEd0I7O0FBQUEseUJBRVksTUFBS2tCLEtBRmpCO0FBQUEsVUFFeEJDLFNBRndCLGdCQUV4QkEsU0FGd0I7QUFBQSxVQUViWixTQUZhLGdCQUViQSxTQUZhO0FBQUEsVUFFRkUsU0FGRSxnQkFFRkEsU0FGRTs7QUFHaEMsVUFBSVQsSUFBSixFQUFVO0FBQ1JpRSxRQUFBQSxNQUFNLENBQUNDLE1BQVAsQ0FBY2xFLElBQWQ7QUFDRTBELFVBQUFBLFFBQVEsRUFBRTtBQURaLFdBRUt2QyxTQUZMO0FBSUFWLFFBQUFBLFNBQVMsQ0FBQ1QsSUFBRCxDQUFUO0FBQ0EsY0FBS0EsSUFBTCxHQUFZLElBQVo7QUFDRDs7QUFDRE8sTUFBQUEsU0FBUyxDQUFDYyxLQUFELENBQVQ7QUFDRDs7Ozs7Ozs2QkFFUTtBQUFBLHlCQUN1QixLQUFLSCxLQUQ1QjtBQUFBLFVBQ0NTLFFBREQsZ0JBQ0NBLFFBREQ7QUFBQSxVQUNjQyxJQURkOztBQUVQLDBCQUNFQyxvQkFBQ2pCLE1BQUQ7QUFDRSxRQUFBLEdBQUcsRUFBRWU7QUFEUCxTQUVNQyxJQUZOO0FBR0UsUUFBQSxXQUFXLEVBQUUsS0FBS3ZCLFdBSHBCO0FBSUUsUUFBQSxXQUFXLEVBQUUsS0FBS0MsV0FKcEI7QUFLRSxRQUFBLFNBQVMsRUFBRSxLQUFLQztBQUxsQixTQURGO0FBU0Q7Ozs7RUE5RHNCUixxQkFDaEJHLGlEQUNGSCxRQUFRLENBQUNHO0FBQ1ppQixFQUFBQSxTQUFTLEVBQUU7QUFDVG1FLElBQUFBLFNBQVMsRUFBRSxPQURGO0FBRVR4RCxJQUFBQSxXQUFXLEVBQUU7QUFGSjs7O0FBOERmLDJCQUFlN0IsZ0JBQUEsQ0FDZ0IsVUFBQ2lCLEtBQUQsRUFBUWEsR0FBUjtBQUFBLHNCQUFnQkYsb0JBQUMsVUFBRDtBQUFZLElBQUEsUUFBUSxFQUFFRTtBQUF0QixLQUErQmIsS0FBL0IsRUFBaEI7QUFBQSxDQURoQixDQUFmOzs7SUMvRVFOLFNBQXFCQztJQUFmQyxlQUFlRDtBQVU3QixJQUFNRSxpQkFBZSxHQUFHLENBQXhCOztJQUlNd0Ysa0JBREx6Rjs7Ozs7Ozs7Ozs7Ozs7OztVQVVDVixVQUFVLFlBQU07QUFBQTtBQUFBLFVBQ05KLElBRE0seUJBQ05BLElBRE07QUFBQSxVQUNBUyxTQURBLHlCQUNBQSxTQURBOztBQUVkLFVBQUlULElBQUosRUFBVTtBQUNSLFlBQUlBLElBQUksQ0FBQ29FLFFBQUwsQ0FBY08sTUFBZCxHQUF1QixDQUEzQixFQUE4QjtBQUM1QmxFLFVBQUFBLFNBQVM7QUFDVixTQUZELE1BRU87QUFDTFQsVUFBQUEsSUFBSSxDQUFDNkUsTUFBTDtBQUNBLGdCQUFLN0UsSUFBTCxHQUFZLElBQVo7QUFDRDtBQUNGO0FBQ0Y7O1VBRURLLGNBQWMsVUFBQ1ksU0FBRCxFQUEwQjtBQUFBO0FBQUEsVUFDOUJqQixJQUQ4QiwwQkFDOUJBLElBRDhCOztBQUV0QyxVQUFJaUIsU0FBUyxDQUFDSSxLQUFWLENBQWdCQyxNQUFoQixLQUEyQlAsaUJBQTNCLElBQThDRSxTQUFTLENBQUN1RixTQUFWLENBQW9CQyxLQUF0RSxFQUE2RTtBQUMzRSxZQUFJLENBQUN6RyxJQUFMLEVBQVc7QUFDVCxnQkFBSzRELFFBQUw7O0FBQ0EsZ0JBQUsxQyxLQUFMLENBQVdWLFVBQVgsQ0FBc0JSLElBQXRCO0FBQ0Q7O0FBQ0QsY0FBS1UsWUFBTCxDQUFrQk8sU0FBbEI7QUFDRDs7QUFDRCxZQUFLQyxLQUFMLENBQVdiLFdBQVgsQ0FBdUJZLFNBQXZCO0FBQ0Q7O1VBb0JEUixZQUFZLFlBQU07QUFBQTtBQUFBLFVBQ1JULElBRFEsMEJBQ1JBLElBRFE7O0FBQUEsVUFFUlMsU0FGUSxHQUVNLE1BQUtTLEtBRlgsQ0FFUlQsU0FGUTtBQUdoQlQsTUFBQUEsSUFBSSxDQUFDMEQsUUFBTCxHQUFnQixLQUFoQjtBQUNBakQsTUFBQUEsU0FBUyxDQUFDVCxJQUFELENBQVQ7QUFDQSxZQUFLQSxJQUFMLEdBQVksSUFBWjtBQUNEOzs7Ozs7OytCQXhCVTtBQUFBLHdCQUM4QixLQUFLa0IsS0FEbkM7QUFBQSxVQUNEQyxTQURDLGVBQ0RBLFNBREM7QUFBQSxVQUNVNEMsUUFEVixlQUNVQSxRQURWO0FBQUEsVUFDb0IzQyxLQURwQixlQUNvQkEsS0FEcEI7QUFBQSxVQUVERyxJQUZDLEdBRVFILEtBRlIsQ0FFREcsSUFGQztBQUdULFVBQU12QixJQUFJLEdBQUcsSUFBSXVCLElBQUosQ0FBU0osU0FBVCxDQUFiO0FBQ0EsV0FBS25CLElBQUwsR0FBWUEsSUFBWjtBQUNBLFdBQUtnRSxXQUFMLENBQWlCRCxRQUFqQjtBQUNEOzs7Z0NBRVdBLFVBQWtCO0FBQzVCLFdBQUsvRCxJQUFMLENBQVUrRCxRQUFWLEdBQXFCQSxRQUFyQjtBQUNEOzs7aUNBRVk5QyxXQUFzQjtBQUFBLFVBQ3pCakIsSUFEeUIsR0FDaEIsSUFEZ0IsQ0FDekJBLElBRHlCO0FBRWpDQSxNQUFBQSxJQUFJLENBQUN5QixHQUFMLENBQVNSLFNBQVMsQ0FBQ1MsS0FBbkI7QUFDQSxXQUFLUixLQUFMLENBQVdSLFlBQVgsQ0FBd0JWLElBQUksQ0FBQ3dFLFdBQTdCLEVBQTBDeEUsSUFBMUM7QUFDRDs7OzZCQVVRO0FBQUEseUJBV0gsS0FBS2tCLEtBWEY7QUFBQSxVQUVMQyxTQUZLLGdCQUVMQSxTQUZLO0FBQUEsVUFHTGYsT0FISyxnQkFHTEEsT0FISztBQUFBLFVBSUxDLFdBSkssZ0JBSUxBLFdBSks7QUFBQSxVQUtMSSxTQUxLLGdCQUtMQSxTQUxLO0FBQUEsVUFNTEMsWUFOSyxnQkFNTEEsWUFOSztBQUFBLFVBT0xDLGVBUEssZ0JBT0xBLGVBUEs7QUFBQSxVQVFMUyxLQVJLLGdCQVFMQSxLQVJLO0FBQUEsVUFTTE8sUUFUSyxnQkFTTEEsUUFUSztBQUFBLFVBVUZDLElBVkU7O0FBWVAsMEJBQ0VDLG9CQUFDakIsTUFBRDtBQUNFLFFBQUEsR0FBRyxFQUFFZSxRQURQO0FBRUUsUUFBQSxPQUFPLEVBQUUsS0FBS3ZCLE9BRmhCO0FBR0UsUUFBQSxXQUFXLEVBQUUsS0FBS0M7QUFIcEIsU0FJTXVCLElBSk4sRUFERjtBQVFEOzs7O0VBL0UyQjdCLHFCQUNyQkcsaURBQ0ZILFFBQVEsQ0FBQ0c7QUFDWmlCLEVBQUFBLFNBQVMsRUFBRTtBQUNUVyxJQUFBQSxXQUFXLEVBQUUsT0FESjtBQUVUNEIsSUFBQUEsUUFBUSxFQUFFO0FBRkQ7OztBQStFZixnQ0FBZXpELGdCQUFBLENBQ2dCLFVBQUNpQixLQUFELEVBQVFhLEdBQVI7QUFBQSxzQkFBZ0JGLG9CQUFDLGVBQUQ7QUFBaUIsSUFBQSxRQUFRLEVBQUVFO0FBQTNCLEtBQW9DYixLQUFwQyxFQUFoQjtBQUFBLENBRGhCLENBQWY7OztJQ2pHUUosZUFBeUJEO0lBQWI2RixXQUFhN0Y7O0FBa0JqQyxTQUFTWSxHQUFULENBQWFrRixJQUFiLEVBQW1CQyxJQUFuQixFQUF5QjtBQUN2QixTQUFPLENBQUVELElBQUksR0FBRyxFQUFSLEdBQWVDLElBQUksR0FBRyxFQUF2QixJQUE4QixFQUFyQztBQUNEOztBQUVELFNBQVNDLGVBQVQsR0FBd0Q7QUFBQSxNQUEvQkMsUUFBK0IsdUVBQUosRUFBSTtBQUN0RCxTQUFPLFVBQUF6RixLQUFLO0FBQUEsV0FBSXlGLFFBQVEsQ0FBQ3pDLE9BQVQsQ0FBaUIsVUFBQTBDLE9BQU87QUFBQSxhQUFJQSxPQUFPLElBQUlBLE9BQU8sQ0FBQzFGLEtBQUQsQ0FBdEI7QUFBQSxLQUF4QixDQUFKO0FBQUEsR0FBWjtBQUNEOzs7SUFHZ0MyRixlQUFqQmxHOzs7OztBQVFkLHdCQUFZSSxNQUFaLEVBQTBCO0FBQUE7O0FBQUE7O0FBQ3hCLDhCQUFNQSxNQUFOOztBQUR3QixVQW1DMUIrRixPQW5DMEIsR0FtQ2hCLGdCQUF3RDtBQUFBLFVBQXJEQyxNQUFxRCxRQUFyREEsTUFBcUQ7QUFBQSx3QkFDakMsTUFBS2hHLEtBRDRCO0FBQUEsVUFDeERpRyxNQUR3RCxlQUN4REEsTUFEd0Q7QUFBQSxVQUNoREMsVUFEZ0QsZUFDaERBLFVBRGdEO0FBRWhFQSxNQUFBQSxVQUFVLENBQUMsVUFBQ0MsS0FBRCxFQUFRbkcsS0FBUixFQUFrQjtBQUFBLFlBQ3JCb0csSUFEcUIsR0FDWkQsS0FBSyxDQUFDRSxTQURNLENBQ3JCRCxJQURxQjs7QUFFM0IsWUFBSUosTUFBTSxHQUFHLENBQWIsRUFBZ0I7QUFDZEksVUFBQUEsSUFBSSxHQUFHN0YsR0FBRyxDQUFDNkYsSUFBRCxFQUFPLEdBQVAsQ0FBVjtBQUNBLGNBQUlILE1BQUosRUFBWUEsTUFBTSxDQUFDRyxJQUFELENBQU47QUFDWixpQkFBTztBQUNMQyxZQUFBQSxTQUFTLG1EQUNKckcsS0FBSyxDQUFDcUcsU0FERixHQUVKRixLQUFLLENBQUNFLFNBRkY7QUFHUEQsY0FBQUEsSUFBSSxFQUFKQTtBQUhPO0FBREosV0FBUDtBQU9EOztBQUNELFlBQUlKLE1BQU0sR0FBRyxDQUFULElBQWNJLElBQUksR0FBRyxHQUF6QixFQUE4QjtBQUM1QkEsVUFBQUEsSUFBSSxHQUFHN0YsR0FBRyxDQUFDNkYsSUFBRCxFQUFPLENBQUMsR0FBUixDQUFWO0FBQ0EsY0FBSUgsTUFBSixFQUFZQSxNQUFNLENBQUNHLElBQUQsQ0FBTjtBQUNaLGlCQUFPO0FBQ0xDLFlBQUFBLFNBQVMsbURBQ0pyRyxLQUFLLENBQUNxRyxTQURGLEdBRUpGLEtBQUssQ0FBQ0UsU0FGRjtBQUdQRCxjQUFBQSxJQUFJLEVBQUpBO0FBSE87QUFESixXQUFQO0FBT0Q7O0FBQ0QsZUFBTyxJQUFQO0FBQ0QsT0F6QlMsQ0FBVjtBQTBCRCxLQS9EeUI7O0FBQUEsVUFpRTFCbkgsU0FqRTBCLEdBaUVkLGlCQUF1QjtBQUFBLFVBQXBCcUgsR0FBb0IsU0FBcEJBLEdBQW9CO0FBQUEsVUFDekJDLFNBRHlCLEdBQ1gsTUFBS0osS0FETSxDQUN6QkksU0FEeUI7O0FBRWpDLFVBQUlELEdBQUcsS0FBSyxPQUFSLElBQW1CLENBQUNDLFNBQXhCLEVBQW1DO0FBQUEsMkJBQ0ksTUFBS3ZHLEtBRFQ7QUFBQSxZQUN6QndHLFlBRHlCLGdCQUN6QkEsWUFEeUI7QUFBQSxZQUNYTixVQURXLGdCQUNYQSxVQURXO0FBRWpDQSxRQUFBQSxVQUFVLENBQUMsVUFBQ0MsS0FBRCxFQUFRbkcsS0FBUjtBQUFBLG1EQUNObUcsS0FETTtBQUVUTSxZQUFBQSxXQUFXLG1EQUNOekcsS0FBSyxDQUFDeUcsV0FEQSxHQUVOTixLQUFLLENBQUNNLFdBRkE7QUFHVCw0QkFBYztBQUhMO0FBRkY7QUFBQSxTQUFELENBQVY7O0FBUUEsY0FBS0MsUUFBTCxDQUFjO0FBQUVILFVBQUFBLFNBQVMsRUFBRTtBQUFiLFNBQWQ7O0FBQ0EsWUFBSUMsWUFBSixFQUFrQkEsWUFBWTtBQUMvQjtBQUNGLEtBaEZ5Qjs7QUFBQSxVQWtGMUJ0SCxPQWxGMEIsR0FrRmhCLGlCQUF1QjtBQUFBLFVBQXBCb0gsR0FBb0IsU0FBcEJBLEdBQW9COztBQUMvQixVQUFJQSxHQUFHLEtBQUssT0FBWixFQUFxQjtBQUFBLDJCQUNtQixNQUFLdEcsS0FEeEI7QUFBQSxZQUNYMkcsYUFEVyxnQkFDWEEsYUFEVztBQUFBLFlBQ0lULFVBREosZ0JBQ0lBLFVBREo7QUFFbkJBLFFBQUFBLFVBQVUsQ0FBQyxVQUFDQyxLQUFELEVBQVFuRyxLQUFSO0FBQUEsbURBQ05tRyxLQURNO0FBRVRNLFlBQUFBLFdBQVcsbURBQ056RyxLQUFLLENBQUN5RyxXQURBLEdBRU5OLEtBQUssQ0FBQ00sV0FGQTtBQUdULDRCQUFjO0FBSEw7QUFGRjtBQUFBLFNBQUQsQ0FBVjs7QUFRQSxjQUFLQyxRQUFMLENBQWM7QUFBRUgsVUFBQUEsU0FBUyxFQUFFO0FBQWIsU0FBZDs7QUFDQSxZQUFJSSxhQUFKLEVBQW1CQSxhQUFhO0FBQ2pDO0FBQ0YsS0FoR3lCOztBQUFBLFVBa0cxQnhILFdBbEcwQixHQWtHWixpQkFBMkI7QUFBQSxVQUF4QnFCLEtBQXdCLFNBQXhCQSxLQUF3QjtBQUFBLHdCQUNOLE1BQUsyRixLQURDO0FBQUEsVUFDL0JJLFNBRCtCLGVBQy9CQSxTQUQrQjtBQUFBLFVBQ3BCSyxTQURvQixlQUNwQkEsU0FEb0I7O0FBRXZDLFVBQUlMLFNBQVMsSUFBSSxDQUFDSyxTQUFsQixFQUE2QjtBQUFBLFlBQ25CVixVQURtQixHQUNKLE1BQUtsRyxLQURELENBQ25Ca0csVUFEbUI7QUFFM0JBLFFBQUFBLFVBQVUsQ0FBQyxVQUFDQyxLQUFELEVBQVFuRyxLQUFSO0FBQUEsbURBQ05tRyxLQURNO0FBRVRNLFlBQUFBLFdBQVcsbURBQ056RyxLQUFLLENBQUN5RyxXQURBLEdBRU5OLEtBQUssQ0FBQ00sV0FGQTtBQUdULDRCQUFjO0FBSEw7QUFGRjtBQUFBLFNBQUQsQ0FBVjs7QUFRQSxjQUFLQyxRQUFMLENBQWM7QUFBRUUsVUFBQUEsU0FBUyxFQUFFcEc7QUFBYixTQUFkO0FBQ0Q7QUFDRixLQWhIeUI7O0FBQUEsVUFrSDFCbkIsU0FsSDBCLEdBa0hkLFlBQU07QUFBQSx5QkFDaUIsTUFBSzhHLEtBRHRCO0FBQUEsVUFDUlMsU0FEUSxnQkFDUkEsU0FEUTtBQUFBLFVBQ0dMLFNBREgsZ0JBQ0dBLFNBREg7O0FBRWhCLFVBQUlLLFNBQUosRUFBZTtBQUNiLFlBQUlMLFNBQUosRUFBZTtBQUFBLGNBQ0xMLFVBREssR0FDVSxNQUFLbEcsS0FEZixDQUNMa0csVUFESztBQUViQSxVQUFBQSxVQUFVLENBQUMsVUFBQ0MsS0FBRCxFQUFRbkcsS0FBUjtBQUFBLHFEQUNObUcsS0FETTtBQUVUTSxjQUFBQSxXQUFXLG1EQUNOekcsS0FBSyxDQUFDeUcsV0FEQSxHQUVOTixLQUFLLENBQUNNLFdBRkE7QUFHVCw4QkFBYztBQUhMO0FBRkY7QUFBQSxXQUFELENBQVY7QUFRRDs7QUFDRCxjQUFLQyxRQUFMLENBQWM7QUFBRUUsVUFBQUEsU0FBUyxFQUFFO0FBQWIsU0FBZDtBQUNEO0FBQ0YsS0FsSXlCOztBQUFBLFVBb0kxQnhILFdBcEkwQixHQW9JWixpQkFBMkI7QUFBQSxVQUF4Qm9CLEtBQXdCLFNBQXhCQSxLQUF3QjtBQUFBLHlCQUNULE1BQUtSLEtBREk7QUFBQSxVQUMvQmtHLFVBRCtCLGdCQUMvQkEsVUFEK0I7QUFBQSxVQUNuQmhHLEtBRG1CLGdCQUNuQkEsS0FEbUI7QUFBQSx5QkFFTixNQUFLaUcsS0FGQztBQUFBLFVBRS9CSSxTQUYrQixnQkFFL0JBLFNBRitCO0FBQUEsVUFFcEJLLFNBRm9CLGdCQUVwQkEsU0FGb0I7QUFHdkNWLE1BQUFBLFVBQVUsQ0FBQyxVQUFDQyxLQUFELEVBQVFuRyxLQUFSLEVBQWtCO0FBQzNCLFlBQUk0RyxTQUFKLEVBQWU7QUFDYixpQkFBTztBQUNMUCxZQUFBQSxTQUFTLG1EQUNKckcsS0FBSyxDQUFDcUcsU0FERixHQUVKRixLQUFLLENBQUNFLFNBRkY7QUFHUG5DLGNBQUFBLE1BQU0sRUFDSmhFLEtBQUssQ0FBQzJHLElBQU4sQ0FBVzNDLE1BQVgsQ0FDRzNELEdBREgsQ0FDT0MsS0FBSyxDQUFDd0UsUUFBTixDQUFlNEIsU0FBZixFQUNGRSxRQURFLENBQ08sR0FEUCxDQURQO0FBSks7QUFESixXQUFQO0FBVUQ7O0FBQ0QsZUFBTyxJQUFQO0FBQ0QsT0FkUyxDQUFWOztBQWVBLFVBQUlQLFNBQUosRUFBZTtBQUNiLGNBQUtHLFFBQUwsQ0FBYztBQUFFRSxVQUFBQSxTQUFTLEVBQUVwRztBQUFiLFNBQWQ7QUFDRDtBQUNGLEtBekp5Qjs7QUFFeEIsVUFBSzJGLEtBQUwsR0FBYTtBQUNYSSxNQUFBQSxTQUFTLEVBQUUsS0FEQTtBQUVYSyxNQUFBQSxTQUFTLEVBQUU7QUFGQSxLQUFiO0FBRndCO0FBTXpCOzs7O3dDQUVtQjtBQUFBOztBQUFBLHlCQUMrQixLQUFLNUcsS0FEcEM7QUFBQSxVQUNWRSxLQURVLGdCQUNWQSxLQURVO0FBQUEsVUFDSDZHLFNBREcsZ0JBQ0hBLFNBREc7QUFBQSxVQUNRN0MsTUFEUixnQkFDUUEsTUFEUjtBQUFBLFVBQ2dCZ0MsVUFEaEIsZ0JBQ2dCQSxVQURoQjtBQUVsQkEsTUFBQUEsVUFBVSxDQUFDLFVBQUNDLEtBQUQsRUFBUW5HLEtBQVIsRUFBa0I7QUFBQSx3QkFDU3dGLFFBQVEsQ0FBQ3RGLEtBQUQsRUFBUUYsS0FBSyxDQUFDeUcsV0FBZCxDQURqQjtBQUFBLFlBQ25CVixPQURtQixhQUNuQkEsT0FEbUI7QUFBQSxZQUNQVSxXQURPOztBQUFBLHlCQUl2QmpCLFFBQVEsQ0FBQ3RGLEtBQUQsRUFBUUYsS0FBSyxDQUFDcUcsU0FBZCxDQUplO0FBQUEsWUFHekJwSCxTQUh5QixjQUd6QkEsU0FIeUI7QUFBQSxZQUdkQyxPQUhjLGNBR2RBLE9BSGM7QUFBQSxZQUdMQyxXQUhLLGNBR0xBLFdBSEs7QUFBQSxZQUdRQyxXQUhSLGNBR1FBLFdBSFI7QUFBQSxZQUdxQkMsU0FIckIsY0FHcUJBLFNBSHJCO0FBQUEsWUFHbUNnSCxTQUhuQzs7QUFLM0IsZUFBTztBQUNMSSxVQUFBQSxXQUFXLG9DQUNOQSxXQURNO0FBRVRWLFlBQUFBLE9BQU8sRUFBRUosZUFBZSxDQUFDLENBQUNJLE9BQUQsRUFBVSxNQUFJLENBQUNBLE9BQWYsQ0FBRCxDQUZmO0FBR1QsMEJBQWM7QUFITCxZQUROO0FBTUxNLFVBQUFBLFNBQVMsb0NBQ0pBLFNBREk7QUFFUHBILFlBQUFBLFNBQVMsRUFBRTBHLGVBQWUsQ0FBQyxDQUFDMUcsU0FBRCxFQUFZLE1BQUksQ0FBQ0EsU0FBakIsQ0FBRCxDQUZuQjtBQUdQQyxZQUFBQSxPQUFPLEVBQUV5RyxlQUFlLENBQUMsQ0FBQ3pHLE9BQUQsRUFBVSxNQUFJLENBQUNBLE9BQWYsQ0FBRCxDQUhqQjtBQUlQQyxZQUFBQSxXQUFXLEVBQUV3RyxlQUFlLENBQUMsQ0FBQ3hHLFdBQUQsRUFBYyxNQUFJLENBQUNBLFdBQW5CLENBQUQsQ0FKckI7QUFLUEMsWUFBQUEsV0FBVyxFQUFFdUcsZUFBZSxDQUFDLENBQUN2RyxXQUFELEVBQWMsTUFBSSxDQUFDQSxXQUFuQixDQUFELENBTHJCO0FBTVBDLFlBQUFBLFNBQVMsRUFBRXNHLGVBQWUsQ0FBQyxDQUFDdEcsU0FBRCxFQUFZLE1BQUksQ0FBQ0EsU0FBakIsQ0FBRCxDQU5uQjtBQU9QK0csWUFBQUEsSUFBSSxFQUFFVyxTQVBDO0FBUVA3QyxZQUFBQSxNQUFNLEVBQU5BO0FBUk87QUFOSixTQUFQO0FBaUJELE9BdEJTLENBQVY7QUF1QkQ7Ozs2QkEwSFE7QUFBQSxVQUNDOEMsUUFERCxHQUNjLEtBQUtoSCxLQURuQixDQUNDZ0gsUUFERDtBQUVQLGFBQU9BLFFBQVA7QUFDRDs7OztFQXRLbURqSSw0QkFDN0NDLGVBQWU7QUFDcEIrSCxFQUFBQSxTQUFTLEVBQUUsQ0FEUztBQUVwQlAsRUFBQUEsWUFBWSxFQUFFLHdCQUFNLEVBRkE7QUFHcEJHLEVBQUFBLGFBQWEsRUFBRSx5QkFBTSxFQUhEO0FBSXBCVixFQUFBQSxNQUFNLEVBQUUsa0JBQU07QUFKTTs7O0lDM0JoQnZHLFNBQXFCQztJQUFmQyxlQUFlRDtBQVM3QixJQUFNRSxpQkFBZSxHQUFHLENBQXhCOztJQUlNb0gsY0FETHJIOzs7Ozs7Ozs7Ozs7Ozs7O1VBVUNULGNBQWMsVUFBQ1ksU0FBRCxFQUEwQjtBQUFBLHdCQUNnQixNQUFLQyxLQURyQjtBQUFBLFVBQzlCQyxTQUQ4QixlQUM5QkEsU0FEOEI7QUFBQSxVQUNuQmQsV0FEbUIsZUFDbkJBLFdBRG1CO0FBQUEsVUFDTkcsVUFETSxlQUNOQSxVQURNO0FBQUEsVUFDTVksS0FETixlQUNNQSxLQUROOztBQUV0QyxVQUFJSCxTQUFTLENBQUNJLEtBQVYsQ0FBZ0JDLE1BQWhCLEtBQTJCUCxpQkFBL0IsRUFBZ0Q7QUFBQSxZQUN0Q1EsSUFEc0MsR0FDdEJILEtBRHNCLENBQ3RDRyxJQURzQztBQUFBLFlBQ2hDcUUsS0FEZ0MsR0FDdEJ4RSxLQURzQixDQUNoQ3dFLEtBRGdDO0FBRTlDLFlBQU1DLEtBQUssR0FBRzVFLFNBQVMsQ0FBQ1MsS0FBeEI7QUFDQSxZQUFNMUIsSUFBSSxHQUFHLElBQUl1QixJQUFJLENBQUM2RyxPQUFULENBQWlCO0FBQzVCMUcsVUFBQUEsS0FBSyxFQUFFbUUsS0FEcUI7QUFFNUJFLFVBQUFBLElBQUksRUFBRSxDQUFDLENBQUQsRUFBSSxDQUFKLENBRnNCO0FBRzVCVCxVQUFBQSxTQUFTLEVBQUVuRSxTQUFTLENBQUM2RSxpQkFBVixJQUErQixJQUFJSixLQUFKLENBQVUsR0FBVixFQUFlLEdBQWYsRUFBb0IsQ0FBcEIsRUFBdUIsSUFBdkIsQ0FIZDtBQUk1QmxDLFVBQUFBLFFBQVEsRUFBRTtBQUprQixTQUFqQixDQUFiO0FBT0EsY0FBSzFELElBQUwsR0FBWUEsSUFBWjtBQUNBLGNBQUs2RixLQUFMLEdBQWFBLEtBQWI7QUFDQXJGLFFBQUFBLFVBQVUsQ0FBQyxNQUFLUixJQUFOLENBQVY7QUFDRDs7QUFDREssTUFBQUEsV0FBVyxDQUFDWSxTQUFELENBQVg7QUFDRDs7VUFFRFgsY0FBYyxVQUFDVyxTQUFELEVBQTBCO0FBQUEsVUFDOUJYLFdBRDhCLEdBQ2QsTUFBS1ksS0FEUyxDQUM5QlosV0FEOEI7O0FBRXRDLFVBQUlXLFNBQVMsQ0FBQ0ksS0FBVixDQUFnQkcsT0FBaEIsS0FBNEIsQ0FBaEMsRUFBbUM7QUFBQTtBQUFBLFlBQ3pCeEIsSUFEeUIseUJBQ3pCQSxJQUR5QjtBQUFBLFlBQ25CNkYsS0FEbUIseUJBQ25CQSxLQURtQjs7QUFBQSxZQUV6QlgsTUFGeUIsR0FFZGxGLElBRmMsQ0FFekJrRixNQUZ5QjtBQUdqQyxZQUFNZSxNQUFNLEdBQUdoRixTQUFTLENBQUNTLEtBQVYsQ0FBZ0J3RSxRQUFoQixDQUF5QkwsS0FBekIsQ0FBZjtBQUNBLFlBQU16RCxLQUFLLEdBQUdTLElBQUksQ0FBQ3NELEdBQUwsQ0FBU0YsTUFBTSxDQUFDckQsQ0FBaEIsQ0FBZDtBQUNBLFlBQU1QLE1BQU0sR0FBR1EsSUFBSSxDQUFDc0QsR0FBTCxDQUFTRixNQUFNLENBQUNsRCxDQUFoQixDQUFmOztBQUNBLFlBQUlrRCxNQUFNLENBQUNyRCxDQUFQLEdBQVcsQ0FBZixFQUFrQjtBQUNoQnNDLFVBQUFBLE1BQU0sQ0FBQzNDLElBQVAsR0FBY3RCLFNBQVMsQ0FBQ1MsS0FBVixDQUFnQmtCLENBQTlCO0FBQ0FzQyxVQUFBQSxNQUFNLENBQUMxQyxLQUFQLEdBQWVxRCxLQUFLLENBQUNqRCxDQUFyQjtBQUNELFNBSEQsTUFHTztBQUNMc0MsVUFBQUEsTUFBTSxDQUFDM0MsSUFBUCxHQUFjc0QsS0FBSyxDQUFDakQsQ0FBcEI7QUFDRDs7QUFDRCxZQUFJcUQsTUFBTSxDQUFDbEQsQ0FBUCxHQUFXLENBQWYsRUFBa0I7QUFDaEJtQyxVQUFBQSxNQUFNLENBQUM1QyxHQUFQLEdBQWF1RCxLQUFLLENBQUM5QyxDQUFuQjtBQUNBbUMsVUFBQUEsTUFBTSxDQUFDekMsTUFBUCxHQUFnQnhCLFNBQVMsQ0FBQ1MsS0FBVixDQUFnQnFCLENBQWhDO0FBQ0QsU0FIRCxNQUdPO0FBQ0xtQyxVQUFBQSxNQUFNLENBQUM1QyxHQUFQLEdBQWFyQixTQUFTLENBQUNTLEtBQVYsQ0FBZ0JxQixDQUE3QjtBQUNEOztBQUNELFlBQUlYLEtBQUssR0FBRyxDQUFaLEVBQWU7QUFDYjhDLFVBQUFBLE1BQU0sQ0FBQzlDLEtBQVAsR0FBZUEsS0FBZjtBQUNEOztBQUNELFlBQUlDLE1BQU0sR0FBRyxDQUFiLEVBQWdCO0FBQ2Q2QyxVQUFBQSxNQUFNLENBQUM3QyxNQUFQLEdBQWdCQSxNQUFoQjtBQUNEO0FBQ0Y7O0FBQ0QvQixNQUFBQSxXQUFXLENBQUNXLFNBQUQsQ0FBWDtBQUNEOztVQUVEVixZQUFZLFVBQUNjLEtBQUQsRUFBc0I7QUFBQTtBQUFBLFVBQ3hCckIsSUFEd0IsMEJBQ3hCQSxJQUR3Qjs7QUFBQSx5QkFFWSxNQUFLa0IsS0FGakI7QUFBQSxVQUV4QkMsU0FGd0IsZ0JBRXhCQSxTQUZ3QjtBQUFBLFVBRWJaLFNBRmEsZ0JBRWJBLFNBRmE7QUFBQSxVQUVGRSxTQUZFLGdCQUVGQSxTQUZFOztBQUdoQyxVQUFJVCxJQUFKLEVBQVU7QUFDUmlFLFFBQUFBLE1BQU0sQ0FBQ0MsTUFBUCxDQUFjbEUsSUFBZDtBQUNFMEQsVUFBQUEsUUFBUSxFQUFFO0FBRFosV0FFS3ZDLFNBRkw7QUFJQVYsUUFBQUEsU0FBUyxDQUFDVCxJQUFELENBQVQ7QUFDQSxjQUFLQSxJQUFMLEdBQVksSUFBWjtBQUNBLGNBQUs2RixLQUFMLEdBQWEsSUFBYjtBQUNEOztBQUNEdEYsTUFBQUEsU0FBUyxDQUFDYyxLQUFELENBQVQ7QUFDRDs7VUFFRHdFOzs7Ozs7NkJBRVM7QUFBQSx5QkFDdUIsS0FBSzNFLEtBRDVCO0FBQUEsVUFDQ1MsUUFERCxnQkFDQ0EsUUFERDtBQUFBLFVBQ2NDLElBRGQ7O0FBRVAsMEJBQ0VDLG9CQUFDakIsTUFBRCxlQUNNZ0IsSUFETjtBQUVFLFFBQUEsR0FBRyxFQUFFRCxRQUZQO0FBR0UsUUFBQSxXQUFXLEVBQUUsS0FBS3RCLFdBSHBCO0FBSUUsUUFBQSxXQUFXLEVBQUUsS0FBS0MsV0FKcEI7QUFLRSxRQUFBLFNBQVMsRUFBRSxLQUFLQztBQUxsQixTQURGO0FBU0Q7Ozs7RUF0RnVCUixxQkFDakJHLGlEQUNGSCxRQUFRLENBQUNHO0FBQ1ppQixFQUFBQSxTQUFTLEVBQUU7QUFDVG1FLElBQUFBLFNBQVMsRUFBRSxPQURGO0FBRVR4RCxJQUFBQSxXQUFXLEVBQUU7QUFGSjs7O0FBc0ZmLDRCQUFlN0IsZ0JBQUEsQ0FDZ0IsVUFBQ2lCLEtBQUQsRUFBUWEsR0FBUjtBQUFBLHNCQUFnQkYsb0JBQUMsV0FBRDtBQUFhLElBQUEsUUFBUSxFQUFFRTtBQUF2QixLQUFnQ2IsS0FBaEMsRUFBaEI7QUFBQSxDQURoQixDQUFmOzs7Ozs7Ozs7Ozs7OyJ9
